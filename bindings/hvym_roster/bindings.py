# This file was generated by stellar_contract_bindings v0.5.0b0 and stellar_sdk v13.2.0.

from __future__ import annotations

from enum import IntEnum, Enum
from typing import Dict, List, Tuple, Optional, Union

from stellar_sdk import scval, xdr, Address, MuxedAccount, Keypair
from stellar_sdk.contract import AssembledTransaction, ContractClient
from stellar_sdk.contract import AssembledTransactionAsync, ContractClientAsync

NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"


class KindKind(Enum):
    Instance = "Instance"
    Permanent = "Permanent"
    Temporary = "Temporary"


class Kind:
    def __init__(
        self,
        kind: KindKind,
    ):
        self.kind = kind

    def to_scval(self) -> xdr.SCVal:
        if self.kind == KindKind.Instance:
            return scval.to_enum(self.kind.name, None)
        if self.kind == KindKind.Permanent:
            return scval.to_enum(self.kind.name, None)
        if self.kind == KindKind.Temporary:
            return scval.to_enum(self.kind.name, None)
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = KindKind(elements[0])
        if kind == KindKind.Instance:
            return cls(kind)
        if kind == KindKind.Permanent:
            return cls(kind)
        if kind == KindKind.Temporary:
            return cls(kind)
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Kind):
            return NotImplemented
        if self.kind != other.kind:
            return False
        return True

    def __hash__(self) -> int:
        return hash(self.kind)


class Member:
    address: Address
    canon: bytes
    name: bytes
    paid: int

    def __init__(
        self, address: Union[Address, str], canon: bytes, name: bytes, paid: int
    ):
        self.address = address
        self.canon = canon
        self.name = name
        self.paid = paid

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "address": scval.to_address(self.address),
                "canon": scval.to_string(self.canon),
                "name": scval.to_string(self.name),
                "paid": scval.to_uint32(self.paid),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_address(elements["address"]),
            scval.from_string(elements["canon"]),
            scval.from_string(elements["name"]),
            scval.from_uint32(elements["paid"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Member):
            return NotImplemented
        return (
            self.address == other.address
            and self.canon == other.canon
            and self.name == other.name
            and self.paid == other.paid
        )

    def __hash__(self) -> int:
        return hash((self.address, self.canon, self.name, self.paid))


class Roster:
    join_fee: int
    pay_token: Address
    symbol: str

    def __init__(self, join_fee: int, pay_token: Union[Address, str], symbol: str):
        self.join_fee = join_fee
        self.pay_token = pay_token
        self.symbol = symbol

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "join_fee": scval.to_uint32(self.join_fee),
                "pay_token": scval.to_address(self.pay_token),
                "symbol": scval.to_symbol(self.symbol),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_uint32(elements["join_fee"]),
            scval.from_address(elements["pay_token"]),
            scval.from_symbol(elements["symbol"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Roster):
            return NotImplemented
        return (
            self.join_fee == other.join_fee
            and self.pay_token == other.pay_token
            and self.symbol == other.symbol
        )

    def __hash__(self) -> int:
        return hash((self.join_fee, self.pay_token, self.symbol))


class DatakeyKind(Enum):
    Member = "Member"
    Roster = "Roster"
    Admin = "Admin"
    AdminList = "AdminList"


class Datakey:
    def __init__(
        self,
        kind: DatakeyKind,
        member: Optional[Union[Address, str]] = None,
    ):
        self.kind = kind
        self.member = member

    def to_scval(self) -> xdr.SCVal:
        if self.kind == DatakeyKind.Member:
            assert self.member is not None
            return scval.to_enum(self.kind.name, scval.to_address(self.member))
        if self.kind == DatakeyKind.Roster:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DatakeyKind.Admin:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DatakeyKind.AdminList:
            return scval.to_enum(self.kind.name, None)
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = DatakeyKind(elements[0])
        if kind == DatakeyKind.Member:
            assert elements[1] is not None and isinstance(elements[1], xdr.SCVal)
            return cls(kind, member=scval.from_address(elements[1]))
        if kind == DatakeyKind.Roster:
            return cls(kind)
        if kind == DatakeyKind.Admin:
            return cls(kind)
        if kind == DatakeyKind.AdminList:
            return cls(kind)
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Datakey):
            return NotImplemented
        if self.kind != other.kind:
            return False
        if self.kind == DatakeyKind.Member:
            return self.member == other.member
        return True

    def __hash__(self) -> int:
        if self.kind == DatakeyKind.Member:
            return hash((self.kind, self.member))
        return hash(self.kind)


class JoinEvent:
    amount: int
    canon: bytes
    member: Address
    name: bytes

    def __init__(
        self, amount: int, canon: bytes, member: Union[Address, str], name: bytes
    ):
        self.amount = amount
        self.canon = canon
        self.member = member
        self.name = name

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "amount": scval.to_uint32(self.amount),
                "canon": scval.to_string(self.canon),
                "member": scval.to_address(self.member),
                "name": scval.to_string(self.name),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_uint32(elements["amount"]),
            scval.from_string(elements["canon"]),
            scval.from_address(elements["member"]),
            scval.from_string(elements["name"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, JoinEvent):
            return NotImplemented
        return (
            self.amount == other.amount
            and self.canon == other.canon
            and self.member == other.member
            and self.name == other.name
        )

    def __hash__(self) -> int:
        return hash((self.amount, self.canon, self.member, self.name))


class AdminEvent:
    admin: Address

    def __init__(self, admin: Union[Address, str]):
        self.admin = admin

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct({"admin": scval.to_address(self.admin)})

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(scval.from_address(elements["admin"]))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, AdminEvent):
            return NotImplemented
        return self.admin == other.admin

    def __hash__(self) -> int:
        return hash((self.admin))


class RemoveEvent:
    member: Address

    def __init__(self, member: Union[Address, str]):
        self.member = member

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct({"member": scval.to_address(self.member)})

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(scval.from_address(elements["member"]))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RemoveEvent):
            return NotImplemented
        return self.member == other.member

    def __hash__(self) -> int:
        return hash((self.member))


class Client(ContractClient):
    def join(
        self,
        caller: Union[Address, str],
        name: bytes,
        canon: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "join",
            [scval.to_address(caller), scval.to_string(name), scval.to_string(canon)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def remove(
        self,
        admin_caller: Union[Address, str],
        member_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "remove",
            [scval.to_address(admin_caller), scval.to_address(member_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[str]:
        return self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_admin(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_admin",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def join_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "join_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def withdraw(
        self,
        caller: Union[Address, str],
        recipient: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "withdraw",
            [scval.to_address(caller), scval.to_address(recipient)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def add_admin(
        self,
        caller: Union[Address, str],
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "add_admin",
            [scval.to_address(caller), scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_canon(
        self,
        member_address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Optional[bytes]]:
        """Get the canon for a member

        # Arguments
        * `e` - The environment
        * `member_address` - The address of the member to query

        # Returns
        * `Option<String>` - The member's canon if they exist, None otherwise"""
        return self.invoke(
            "get_canon",
            [scval.to_address(member_address)],
            parse_result_xdr_fn=lambda v: (
                scval.from_string(v)
                if v.type != xdr.SCValType.SCV_VOID
                else scval.from_void(v)
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_member(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_member",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def member_paid(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "member_paid",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def remove_admin(
        self,
        caller: Union[Address, str],
        admin_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "remove_admin",
            [scval.to_address(caller), scval.to_address(admin_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_canon(
        self,
        caller: Union[Address, str],
        member_address: Union[Address, str],
        new_canon: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        """Update the canon for a member

        # Arguments
        * `e` - The environment
        * `caller` - The address of the member updating their canon (must be the member themselves or an admin)
        * `member_address` - The address of the member whose canon is being updated
        * `new_canon` - The new canon string (max 100 characters)

        # Returns
        * `bool` - True if the update was successful"""
        return self.invoke(
            "update_canon",
            [
                scval.to_address(caller),
                scval.to_address(member_address),
                scval.to_string(new_canon),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def fund_contract(
        self,
        caller: Union[Address, str],
        fund_amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "fund_contract",
            [scval.to_address(caller), scval.to_uint32(fund_amount)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_admin_list(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[Address]]:
        return self.invoke(
            "get_admin_list",
            [],
            parse_result_xdr_fn=lambda v: [
                scval.from_address(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_join_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "update_join_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )


class ClientAsync(ContractClientAsync):
    async def join(
        self,
        caller: Union[Address, str],
        name: bytes,
        canon: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "join",
            [scval.to_address(caller), scval.to_string(name), scval.to_string(canon)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def remove(
        self,
        admin_caller: Union[Address, str],
        member_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "remove",
            [scval.to_address(admin_caller), scval.to_address(member_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[str]:
        return await self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_admin(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_admin",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def join_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "join_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def withdraw(
        self,
        caller: Union[Address, str],
        recipient: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "withdraw",
            [scval.to_address(caller), scval.to_address(recipient)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def add_admin(
        self,
        caller: Union[Address, str],
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "add_admin",
            [scval.to_address(caller), scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_canon(
        self,
        member_address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Optional[bytes]]:
        """Get the canon for a member

        # Arguments
        * `e` - The environment
        * `member_address` - The address of the member to query

        # Returns
        * `Option<String>` - The member's canon if they exist, None otherwise"""
        return await self.invoke(
            "get_canon",
            [scval.to_address(member_address)],
            parse_result_xdr_fn=lambda v: (
                scval.from_string(v)
                if v.type != xdr.SCValType.SCV_VOID
                else scval.from_void(v)
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_member(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_member",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def member_paid(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "member_paid",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def remove_admin(
        self,
        caller: Union[Address, str],
        admin_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "remove_admin",
            [scval.to_address(caller), scval.to_address(admin_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_canon(
        self,
        caller: Union[Address, str],
        member_address: Union[Address, str],
        new_canon: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        """Update the canon for a member

        # Arguments
        * `e` - The environment
        * `caller` - The address of the member updating their canon (must be the member themselves or an admin)
        * `member_address` - The address of the member whose canon is being updated
        * `new_canon` - The new canon string (max 100 characters)

        # Returns
        * `bool` - True if the update was successful"""
        return await self.invoke(
            "update_canon",
            [
                scval.to_address(caller),
                scval.to_address(member_address),
                scval.to_string(new_canon),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def fund_contract(
        self,
        caller: Union[Address, str],
        fund_amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "fund_contract",
            [scval.to_address(caller), scval.to_uint32(fund_amount)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_admin_list(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[Address]]:
        return await self.invoke(
            "get_admin_list",
            [],
            parse_result_xdr_fn=lambda v: [
                scval.from_address(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_join_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "update_join_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )
