# This file was generated by stellar_contract_bindings v0.5.0b0 and stellar_sdk v13.2.0.

from __future__ import annotations

from enum import IntEnum, Enum
from typing import Dict, List, Tuple, Optional, Union

from stellar_sdk import scval, xdr, Address, MuxedAccount, Keypair
from stellar_sdk.contract import AssembledTransaction, ContractClient
from stellar_sdk.contract import AssembledTransactionAsync, ContractClientAsync

NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"


class KindKind(Enum):
    Instance = "Instance"
    Permanent = "Permanent"
    Temporary = "Temporary"


class Kind:
    def __init__(
        self,
        kind: KindKind,
    ):
        self.kind = kind

    def to_scval(self) -> xdr.SCVal:
        if self.kind == KindKind.Instance:
            return scval.to_enum(self.kind.name, None)
        if self.kind == KindKind.Permanent:
            return scval.to_enum(self.kind.name, None)
        if self.kind == KindKind.Temporary:
            return scval.to_enum(self.kind.name, None)
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = KindKind(elements[0])
        if kind == KindKind.Instance:
            return cls(kind)
        if kind == KindKind.Permanent:
            return cls(kind)
        if kind == KindKind.Temporary:
            return cls(kind)
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Kind):
            return NotImplemented
        if self.kind != other.kind:
            return False
        return True

    def __hash__(self) -> int:
        return hash(self.kind)


class Error(IntEnum):
    Unauthorized = 1
    NotAdmin = 2
    AlreadyPinner = 10
    NotPinner = 11
    PinnerInactive = 12
    NoSlotsAvailable = 20
    SlotNotActive = 21
    SlotExpired = 22
    SlotNotExpired = 23
    AlreadyClaimed = 24
    SlotFilled = 25
    NotSlotPublisher = 26
    InvalidSlotId = 27
    DuplicateCid = 28
    AlreadyFlagged = 29
    InsufficientPinQty = 40
    PinQtyExceedsMax = 41
    OfferPriceTooLow = 42
    OfferOverflow = 43
    InvalidCid = 44
    InvalidAmount = 45
    InvalidString = 46
    InsufficientFunds = 50
    TransferFailed = 51
    CannotRemoveInitialAdmin = 60

    def to_scval(self) -> xdr.SCVal:
        return scval.to_uint32(self.value)

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        return cls(scval.from_uint32(val))


class Pinner:
    active: bool
    address: Address
    flags: int
    joined_at: int
    min_price: int
    multiaddr: bytes
    node_id: bytes
    pins_completed: int
    staked: int

    def __init__(
        self,
        active: bool,
        address: Union[Address, str],
        flags: int,
        joined_at: int,
        min_price: int,
        multiaddr: bytes,
        node_id: bytes,
        pins_completed: int,
        staked: int,
    ):
        self.active = active
        self.address = address
        self.flags = flags
        self.joined_at = joined_at
        self.min_price = min_price
        self.multiaddr = multiaddr
        self.node_id = node_id
        self.pins_completed = pins_completed
        self.staked = staked

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "active": scval.to_bool(self.active),
                "address": scval.to_address(self.address),
                "flags": scval.to_uint32(self.flags),
                "joined_at": scval.to_uint64(self.joined_at),
                "min_price": scval.to_uint32(self.min_price),
                "multiaddr": scval.to_string(self.multiaddr),
                "node_id": scval.to_string(self.node_id),
                "pins_completed": scval.to_uint32(self.pins_completed),
                "staked": scval.to_uint32(self.staked),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_bool(elements["active"]),
            scval.from_address(elements["address"]),
            scval.from_uint32(elements["flags"]),
            scval.from_uint64(elements["joined_at"]),
            scval.from_uint32(elements["min_price"]),
            scval.from_string(elements["multiaddr"]),
            scval.from_string(elements["node_id"]),
            scval.from_uint32(elements["pins_completed"]),
            scval.from_uint32(elements["staked"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Pinner):
            return NotImplemented
        return (
            self.active == other.active
            and self.address == other.address
            and self.flags == other.flags
            and self.joined_at == other.joined_at
            and self.min_price == other.min_price
            and self.multiaddr == other.multiaddr
            and self.node_id == other.node_id
            and self.pins_completed == other.pins_completed
            and self.staked == other.staked
        )

    def __hash__(self) -> int:
        return hash(
            (
                self.active,
                self.address,
                self.flags,
                self.joined_at,
                self.min_price,
                self.multiaddr,
                self.node_id,
                self.pins_completed,
                self.staked,
            )
        )


class DataKeyKind(Enum):
    PinService = "PinService"
    Admin = "Admin"
    AdminList = "AdminList"
    Pinner = "Pinner"
    PinnerCount = "PinnerCount"
    Slot = "Slot"
    Flagged = "Flagged"
    Flaggers = "Flaggers"


class DataKey:
    def __init__(
        self,
        kind: DataKeyKind,
        pinner: Optional[Union[Address, str]] = None,
        slot: Optional[int] = None,
        flagged: Optional[Tuple[Union[Address, str], Union[Address, str]]] = None,
        flaggers: Optional[Union[Address, str]] = None,
    ):
        self.kind = kind
        self.pinner = pinner
        self.slot = slot
        self.flagged = flagged
        self.flaggers = flaggers

    def to_scval(self) -> xdr.SCVal:
        if self.kind == DataKeyKind.PinService:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DataKeyKind.Admin:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DataKeyKind.AdminList:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DataKeyKind.Pinner:
            assert self.pinner is not None
            return scval.to_enum(self.kind.name, scval.to_address(self.pinner))
        if self.kind == DataKeyKind.PinnerCount:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DataKeyKind.Slot:
            assert self.slot is not None
            return scval.to_enum(self.kind.name, scval.to_uint32(self.slot))
        if self.kind == DataKeyKind.Flagged:
            assert isinstance(self.flagged, tuple)
            return scval.to_enum(
                self.kind.name,
                [scval.to_address(self.flagged[0]), scval.to_address(self.flagged[1])],
            )
        if self.kind == DataKeyKind.Flaggers:
            assert self.flaggers is not None
            return scval.to_enum(self.kind.name, scval.to_address(self.flaggers))
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = DataKeyKind(elements[0])
        if kind == DataKeyKind.PinService:
            return cls(kind)
        if kind == DataKeyKind.Admin:
            return cls(kind)
        if kind == DataKeyKind.AdminList:
            return cls(kind)
        if kind == DataKeyKind.Pinner:
            assert elements[1] is not None and isinstance(elements[1], xdr.SCVal)
            return cls(kind, pinner=scval.from_address(elements[1]))
        if kind == DataKeyKind.PinnerCount:
            return cls(kind)
        if kind == DataKeyKind.Slot:
            assert elements[1] is not None and isinstance(elements[1], xdr.SCVal)
            return cls(kind, slot=scval.from_uint32(elements[1]))
        if kind == DataKeyKind.Flagged:
            assert elements[1] is not None and isinstance(elements[1], list)
            return cls(
                kind,
                flagged=(
                    scval.from_address(elements[1][0]),
                    scval.from_address(elements[1][1]),
                ),
            )
        if kind == DataKeyKind.Flaggers:
            assert elements[1] is not None and isinstance(elements[1], xdr.SCVal)
            return cls(kind, flaggers=scval.from_address(elements[1]))
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, DataKey):
            return NotImplemented
        if self.kind != other.kind:
            return False
        if self.kind == DataKeyKind.Pinner:
            return self.pinner == other.pinner
        if self.kind == DataKeyKind.Slot:
            return self.slot == other.slot
        if self.kind == DataKeyKind.Flagged:
            return self.flagged == other.flagged
        if self.kind == DataKeyKind.Flaggers:
            return self.flaggers == other.flaggers
        return True

    def __hash__(self) -> int:
        if self.kind == DataKeyKind.Pinner:
            return hash((self.kind, self.pinner))
        if self.kind == DataKeyKind.Slot:
            return hash((self.kind, self.slot))
        if self.kind == DataKeyKind.Flagged:
            return hash((self.kind, self.flagged))
        if self.kind == DataKeyKind.Flaggers:
            return hash((self.kind, self.flaggers))
        return hash(self.kind)


class PinSlot:
    cid_hash: bytes
    claims: List[Address]
    created_at: int
    escrow_balance: int
    offer_price: int
    pin_qty: int
    pins_remaining: int
    publisher: Address

    def __init__(
        self,
        cid_hash: bytes,
        claims: List[Union[Address, str]],
        created_at: int,
        escrow_balance: int,
        offer_price: int,
        pin_qty: int,
        pins_remaining: int,
        publisher: Union[Address, str],
    ):
        self.cid_hash = cid_hash
        self.claims = claims
        self.created_at = created_at
        self.escrow_balance = escrow_balance
        self.offer_price = offer_price
        self.pin_qty = pin_qty
        self.pins_remaining = pins_remaining
        self.publisher = publisher

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "cid_hash": scval.to_bytes(self.cid_hash),
                "claims": scval.to_vec([scval.to_address(e) for e in self.claims]),
                "created_at": scval.to_uint32(self.created_at),
                "escrow_balance": scval.to_uint32(self.escrow_balance),
                "offer_price": scval.to_uint32(self.offer_price),
                "pin_qty": scval.to_uint32(self.pin_qty),
                "pins_remaining": scval.to_uint32(self.pins_remaining),
                "publisher": scval.to_address(self.publisher),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_bytes(elements["cid_hash"]),
            [scval.from_address(e) for e in scval.from_vec(elements["claims"])],
            scval.from_uint32(elements["created_at"]),
            scval.from_uint32(elements["escrow_balance"]),
            scval.from_uint32(elements["offer_price"]),
            scval.from_uint32(elements["pin_qty"]),
            scval.from_uint32(elements["pins_remaining"]),
            scval.from_address(elements["publisher"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PinSlot):
            return NotImplemented
        return (
            self.cid_hash == other.cid_hash
            and self.claims == other.claims
            and self.created_at == other.created_at
            and self.escrow_balance == other.escrow_balance
            and self.offer_price == other.offer_price
            and self.pin_qty == other.pin_qty
            and self.pins_remaining == other.pins_remaining
            and self.publisher == other.publisher
        )

    def __hash__(self) -> int:
        return hash(
            (
                self.cid_hash,
                self.claims,
                self.created_at,
                self.escrow_balance,
                self.offer_price,
                self.pin_qty,
                self.pins_remaining,
                self.publisher,
            )
        )


class PinEvent:
    cid: bytes
    filename: bytes
    gateway: bytes
    offer_price: int
    pin_qty: int
    publisher: Address
    slot_id: int

    def __init__(
        self,
        cid: bytes,
        filename: bytes,
        gateway: bytes,
        offer_price: int,
        pin_qty: int,
        publisher: Union[Address, str],
        slot_id: int,
    ):
        self.cid = cid
        self.filename = filename
        self.gateway = gateway
        self.offer_price = offer_price
        self.pin_qty = pin_qty
        self.publisher = publisher
        self.slot_id = slot_id

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "cid": scval.to_string(self.cid),
                "filename": scval.to_string(self.filename),
                "gateway": scval.to_string(self.gateway),
                "offer_price": scval.to_uint32(self.offer_price),
                "pin_qty": scval.to_uint32(self.pin_qty),
                "publisher": scval.to_address(self.publisher),
                "slot_id": scval.to_uint32(self.slot_id),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_string(elements["cid"]),
            scval.from_string(elements["filename"]),
            scval.from_string(elements["gateway"]),
            scval.from_uint32(elements["offer_price"]),
            scval.from_uint32(elements["pin_qty"]),
            scval.from_address(elements["publisher"]),
            scval.from_uint32(elements["slot_id"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PinEvent):
            return NotImplemented
        return (
            self.cid == other.cid
            and self.filename == other.filename
            and self.gateway == other.gateway
            and self.offer_price == other.offer_price
            and self.pin_qty == other.pin_qty
            and self.publisher == other.publisher
            and self.slot_id == other.slot_id
        )

    def __hash__(self) -> int:
        return hash(
            (
                self.cid,
                self.filename,
                self.gateway,
                self.offer_price,
                self.pin_qty,
                self.publisher,
                self.slot_id,
            )
        )


class AdminEvent:
    admin: Address

    def __init__(self, admin: Union[Address, str]):
        self.admin = admin

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct({"admin": scval.to_address(self.admin)})

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(scval.from_address(elements["admin"]))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, AdminEvent):
            return NotImplemented
        return self.admin == other.admin

    def __hash__(self) -> int:
        return hash((self.admin))


class PinService:
    fees_collected: int
    flag_threshold: int
    join_fee: int
    max_cycles: int
    min_offer_price: int
    min_pin_qty: int
    pay_token: Address
    pin_fee: int
    pinner_stake: int
    start_ledger: int
    symbol: str

    def __init__(
        self,
        fees_collected: int,
        flag_threshold: int,
        join_fee: int,
        max_cycles: int,
        min_offer_price: int,
        min_pin_qty: int,
        pay_token: Union[Address, str],
        pin_fee: int,
        pinner_stake: int,
        start_ledger: int,
        symbol: str,
    ):
        self.fees_collected = fees_collected
        self.flag_threshold = flag_threshold
        self.join_fee = join_fee
        self.max_cycles = max_cycles
        self.min_offer_price = min_offer_price
        self.min_pin_qty = min_pin_qty
        self.pay_token = pay_token
        self.pin_fee = pin_fee
        self.pinner_stake = pinner_stake
        self.start_ledger = start_ledger
        self.symbol = symbol

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "fees_collected": scval.to_int128(self.fees_collected),
                "flag_threshold": scval.to_uint32(self.flag_threshold),
                "join_fee": scval.to_uint32(self.join_fee),
                "max_cycles": scval.to_uint32(self.max_cycles),
                "min_offer_price": scval.to_uint32(self.min_offer_price),
                "min_pin_qty": scval.to_uint32(self.min_pin_qty),
                "pay_token": scval.to_address(self.pay_token),
                "pin_fee": scval.to_uint32(self.pin_fee),
                "pinner_stake": scval.to_uint32(self.pinner_stake),
                "start_ledger": scval.to_uint32(self.start_ledger),
                "symbol": scval.to_symbol(self.symbol),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_int128(elements["fees_collected"]),
            scval.from_uint32(elements["flag_threshold"]),
            scval.from_uint32(elements["join_fee"]),
            scval.from_uint32(elements["max_cycles"]),
            scval.from_uint32(elements["min_offer_price"]),
            scval.from_uint32(elements["min_pin_qty"]),
            scval.from_address(elements["pay_token"]),
            scval.from_uint32(elements["pin_fee"]),
            scval.from_uint32(elements["pinner_stake"]),
            scval.from_uint32(elements["start_ledger"]),
            scval.from_symbol(elements["symbol"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PinService):
            return NotImplemented
        return (
            self.fees_collected == other.fees_collected
            and self.flag_threshold == other.flag_threshold
            and self.join_fee == other.join_fee
            and self.max_cycles == other.max_cycles
            and self.min_offer_price == other.min_offer_price
            and self.min_pin_qty == other.min_pin_qty
            and self.pay_token == other.pay_token
            and self.pin_fee == other.pin_fee
            and self.pinner_stake == other.pinner_stake
            and self.start_ledger == other.start_ledger
            and self.symbol == other.symbol
        )

    def __hash__(self) -> int:
        return hash(
            (
                self.fees_collected,
                self.flag_threshold,
                self.join_fee,
                self.max_cycles,
                self.min_offer_price,
                self.min_pin_qty,
                self.pay_token,
                self.pin_fee,
                self.pinner_stake,
                self.start_ledger,
                self.symbol,
            )
        )


class UnpinEvent:
    cid_hash: bytes
    slot_id: int

    def __init__(self, cid_hash: bytes, slot_id: int):
        self.cid_hash = cid_hash
        self.slot_id = slot_id

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "cid_hash": scval.to_bytes(self.cid_hash),
                "slot_id": scval.to_uint32(self.slot_id),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_bytes(elements["cid_hash"]),
            scval.from_uint32(elements["slot_id"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, UnpinEvent):
            return NotImplemented
        return self.cid_hash == other.cid_hash and self.slot_id == other.slot_id

    def __hash__(self) -> int:
        return hash((self.cid_hash, self.slot_id))


class PinnedEvent:
    amount: int
    cid_hash: bytes
    pinner: Address
    pins_remaining: int
    slot_id: int

    def __init__(
        self,
        amount: int,
        cid_hash: bytes,
        pinner: Union[Address, str],
        pins_remaining: int,
        slot_id: int,
    ):
        self.amount = amount
        self.cid_hash = cid_hash
        self.pinner = pinner
        self.pins_remaining = pins_remaining
        self.slot_id = slot_id

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "amount": scval.to_uint32(self.amount),
                "cid_hash": scval.to_bytes(self.cid_hash),
                "pinner": scval.to_address(self.pinner),
                "pins_remaining": scval.to_uint32(self.pins_remaining),
                "slot_id": scval.to_uint32(self.slot_id),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_uint32(elements["amount"]),
            scval.from_bytes(elements["cid_hash"]),
            scval.from_address(elements["pinner"]),
            scval.from_uint32(elements["pins_remaining"]),
            scval.from_uint32(elements["slot_id"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PinnedEvent):
            return NotImplemented
        return (
            self.amount == other.amount
            and self.cid_hash == other.cid_hash
            and self.pinner == other.pinner
            and self.pins_remaining == other.pins_remaining
            and self.slot_id == other.slot_id
        )

    def __hash__(self) -> int:
        return hash(
            (self.amount, self.cid_hash, self.pinner, self.pins_remaining, self.slot_id)
        )


class JoinPinnerEvent:
    node_id: bytes
    pinner: Address

    def __init__(self, node_id: bytes, pinner: Union[Address, str]):
        self.node_id = node_id
        self.pinner = pinner

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "node_id": scval.to_string(self.node_id),
                "pinner": scval.to_address(self.pinner),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_string(elements["node_id"]),
            scval.from_address(elements["pinner"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, JoinPinnerEvent):
            return NotImplemented
        return self.node_id == other.node_id and self.pinner == other.pinner

    def __hash__(self) -> int:
        return hash((self.node_id, self.pinner))


class RemovePinnerEvent:
    pinner: Address

    def __init__(self, pinner: Union[Address, str]):
        self.pinner = pinner

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct({"pinner": scval.to_address(self.pinner)})

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(scval.from_address(elements["pinner"]))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, RemovePinnerEvent):
            return NotImplemented
        return self.pinner == other.pinner

    def __hash__(self) -> int:
        return hash((self.pinner))


class Client(ContractClient):
    def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[str]:
        return self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def balance(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "balance",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def pin_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "pin_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_slot(
        self,
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[PinSlot]:
        return self.invoke(
            "get_slot",
            [scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: PinSlot.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_admin(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_admin",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def join_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "join_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def add_admin(
        self,
        caller: Union[Address, str],
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "add_admin",
            [scval.to_address(caller), scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_pinner(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_pinner",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def pay_token(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Address]:
        return self.invoke(
            "pay_token",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def cancel_pin(
        self,
        caller: Union[Address, str],
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "cancel_pin",
            [scval.to_address(caller), scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def create_pin(
        self,
        caller: Union[Address, str],
        cid: bytes,
        filename: bytes,
        gateway: bytes,
        offer_price: int,
        pin_qty: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "create_pin",
            [
                scval.to_address(caller),
                scval.to_string(cid),
                scval.to_string(filename),
                scval.to_string(gateway),
                scval.to_uint32(offer_price),
                scval.to_uint32(pin_qty),
            ],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_pinner(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Optional[Pinner]]:
        return self.invoke(
            "get_pinner",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: (
                Pinner.from_scval(v)
                if v.type != xdr.SCValType.SCV_VOID
                else scval.from_void(v)
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def max_cycles(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "max_cycles",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def collect_pin(
        self,
        caller: Union[Address, str],
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "collect_pin",
            [scval.to_address(caller), scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def flag_pinner(
        self,
        caller: Union[Address, str],
        pinner_addr: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "flag_pinner",
            [scval.to_address(caller), scval.to_address(pinner_addr)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def min_pin_qty(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "min_pin_qty",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def remove_admin(
        self,
        caller: Union[Address, str],
        admin_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "remove_admin",
            [scval.to_address(caller), scval.to_address(admin_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def current_epoch(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "current_epoch",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def fund_contract(
        self,
        caller: Union[Address, str],
        fund_amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "fund_contract",
            [scval.to_address(caller), scval.to_uint32(fund_amount)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_all_slots(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[PinSlot]]:
        return self.invoke(
            "get_all_slots",
            [],
            parse_result_xdr_fn=lambda v: [
                PinSlot.from_scval(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def remove_pinner(
        self,
        admin_addr: Union[Address, str],
        pinner_addr: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "remove_pinner",
            [scval.to_address(admin_addr), scval.to_address(pinner_addr)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_pinner(
        self,
        caller: Union[Address, str],
        node_id: Optional[bytes],
        multiaddr: Optional[bytes],
        min_price: Optional[int],
        active: Optional[bool],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Pinner]:
        return self.invoke(
            "update_pinner",
            [
                scval.to_address(caller),
                scval.to_string(node_id) if node_id is not None else scval.to_void(),
                (
                    scval.to_string(multiaddr)
                    if multiaddr is not None
                    else scval.to_void()
                ),
                (
                    scval.to_uint32(min_price)
                    if min_price is not None
                    else scval.to_void()
                ),
                scval.to_bool(active) if active is not None else scval.to_void(),
            ],
            parse_result_xdr_fn=lambda v: Pinner.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def withdraw_fees(
        self,
        caller: Union[Address, str],
        recipient: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "withdraw_fees",
            [scval.to_address(caller), scval.to_address(recipient)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def fees_collected(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "fees_collected",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def flag_threshold(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "flag_threshold",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_admin_list(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[Address]]:
        return self.invoke(
            "get_admin_list",
            [],
            parse_result_xdr_fn=lambda v: [
                scval.from_address(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def join_as_pinner(
        self,
        caller: Union[Address, str],
        node_id: bytes,
        multiaddr: bytes,
        min_price: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Pinner]:
        return self.invoke(
            "join_as_pinner",
            [
                scval.to_address(caller),
                scval.to_string(node_id),
                scval.to_string(multiaddr),
                scval.to_uint32(min_price),
            ],
            parse_result_xdr_fn=lambda v: Pinner.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_pin_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "update_pin_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_slot_expired(
        self,
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_slot_expired",
            [scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def leave_as_pinner(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "leave_as_pinner",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def min_offer_price(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "min_offer_price",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_join_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "update_join_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def force_clear_slot(
        self,
        caller: Union[Address, str],
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "force_clear_slot",
            [scval.to_address(caller), scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_pinner_count(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "get_pinner_count",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_max_cycles(
        self,
        caller: Union[Address, str],
        new_max: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "update_max_cycles",
            [scval.to_address(caller), scval.to_uint32(new_max)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def clear_expired_slot(
        self,
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "clear_expired_slot",
            [scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_min_pin_qty(
        self,
        caller: Union[Address, str],
        new_min: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "update_min_pin_qty",
            [scval.to_address(caller), scval.to_uint32(new_min)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def has_available_slots(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "has_available_slots",
            [],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def pinner_stake_amount(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "pinner_stake_amount",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_pinner_stake(
        self,
        caller: Union[Address, str],
        new_stake: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "update_pinner_stake",
            [scval.to_address(caller), scval.to_uint32(new_stake)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_flag_threshold(
        self,
        caller: Union[Address, str],
        new_threshold: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "update_flag_threshold",
            [scval.to_address(caller), scval.to_uint32(new_threshold)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_min_offer_price(
        self,
        caller: Union[Address, str],
        new_min: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "update_min_offer_price",
            [scval.to_address(caller), scval.to_uint32(new_min)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )


class ClientAsync(ContractClientAsync):
    async def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[str]:
        return await self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def balance(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "balance",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def pin_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "pin_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_slot(
        self,
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[PinSlot]:
        return await self.invoke(
            "get_slot",
            [scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: PinSlot.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_admin(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_admin",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def join_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "join_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def add_admin(
        self,
        caller: Union[Address, str],
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "add_admin",
            [scval.to_address(caller), scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_pinner(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_pinner",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def pay_token(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Address]:
        return await self.invoke(
            "pay_token",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def cancel_pin(
        self,
        caller: Union[Address, str],
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "cancel_pin",
            [scval.to_address(caller), scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def create_pin(
        self,
        caller: Union[Address, str],
        cid: bytes,
        filename: bytes,
        gateway: bytes,
        offer_price: int,
        pin_qty: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "create_pin",
            [
                scval.to_address(caller),
                scval.to_string(cid),
                scval.to_string(filename),
                scval.to_string(gateway),
                scval.to_uint32(offer_price),
                scval.to_uint32(pin_qty),
            ],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_pinner(
        self,
        address: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Optional[Pinner]]:
        return await self.invoke(
            "get_pinner",
            [scval.to_address(address)],
            parse_result_xdr_fn=lambda v: (
                Pinner.from_scval(v)
                if v.type != xdr.SCValType.SCV_VOID
                else scval.from_void(v)
            ),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def max_cycles(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "max_cycles",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def collect_pin(
        self,
        caller: Union[Address, str],
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "collect_pin",
            [scval.to_address(caller), scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def flag_pinner(
        self,
        caller: Union[Address, str],
        pinner_addr: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "flag_pinner",
            [scval.to_address(caller), scval.to_address(pinner_addr)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def min_pin_qty(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "min_pin_qty",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def remove_admin(
        self,
        caller: Union[Address, str],
        admin_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "remove_admin",
            [scval.to_address(caller), scval.to_address(admin_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def current_epoch(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "current_epoch",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def fund_contract(
        self,
        caller: Union[Address, str],
        fund_amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "fund_contract",
            [scval.to_address(caller), scval.to_uint32(fund_amount)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_all_slots(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[PinSlot]]:
        return await self.invoke(
            "get_all_slots",
            [],
            parse_result_xdr_fn=lambda v: [
                PinSlot.from_scval(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def remove_pinner(
        self,
        admin_addr: Union[Address, str],
        pinner_addr: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "remove_pinner",
            [scval.to_address(admin_addr), scval.to_address(pinner_addr)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_pinner(
        self,
        caller: Union[Address, str],
        node_id: Optional[bytes],
        multiaddr: Optional[bytes],
        min_price: Optional[int],
        active: Optional[bool],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Pinner]:
        return await self.invoke(
            "update_pinner",
            [
                scval.to_address(caller),
                scval.to_string(node_id) if node_id is not None else scval.to_void(),
                (
                    scval.to_string(multiaddr)
                    if multiaddr is not None
                    else scval.to_void()
                ),
                (
                    scval.to_uint32(min_price)
                    if min_price is not None
                    else scval.to_void()
                ),
                scval.to_bool(active) if active is not None else scval.to_void(),
            ],
            parse_result_xdr_fn=lambda v: Pinner.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def withdraw_fees(
        self,
        caller: Union[Address, str],
        recipient: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "withdraw_fees",
            [scval.to_address(caller), scval.to_address(recipient)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def fees_collected(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "fees_collected",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def flag_threshold(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "flag_threshold",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_admin_list(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[Address]]:
        return await self.invoke(
            "get_admin_list",
            [],
            parse_result_xdr_fn=lambda v: [
                scval.from_address(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def join_as_pinner(
        self,
        caller: Union[Address, str],
        node_id: bytes,
        multiaddr: bytes,
        min_price: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Pinner]:
        return await self.invoke(
            "join_as_pinner",
            [
                scval.to_address(caller),
                scval.to_string(node_id),
                scval.to_string(multiaddr),
                scval.to_uint32(min_price),
            ],
            parse_result_xdr_fn=lambda v: Pinner.from_scval(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_pin_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "update_pin_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_slot_expired(
        self,
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_slot_expired",
            [scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def leave_as_pinner(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "leave_as_pinner",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def min_offer_price(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "min_offer_price",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_join_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "update_join_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def force_clear_slot(
        self,
        caller: Union[Address, str],
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "force_clear_slot",
            [scval.to_address(caller), scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_pinner_count(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "get_pinner_count",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_max_cycles(
        self,
        caller: Union[Address, str],
        new_max: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "update_max_cycles",
            [scval.to_address(caller), scval.to_uint32(new_max)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def clear_expired_slot(
        self,
        slot_id: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "clear_expired_slot",
            [scval.to_uint32(slot_id)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_min_pin_qty(
        self,
        caller: Union[Address, str],
        new_min: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "update_min_pin_qty",
            [scval.to_address(caller), scval.to_uint32(new_min)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def has_available_slots(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "has_available_slots",
            [],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def pinner_stake_amount(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "pinner_stake_amount",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_pinner_stake(
        self,
        caller: Union[Address, str],
        new_stake: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "update_pinner_stake",
            [scval.to_address(caller), scval.to_uint32(new_stake)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_flag_threshold(
        self,
        caller: Union[Address, str],
        new_threshold: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "update_flag_threshold",
            [scval.to_address(caller), scval.to_uint32(new_threshold)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_min_offer_price(
        self,
        caller: Union[Address, str],
        new_min: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "update_min_offer_price",
            [scval.to_address(caller), scval.to_uint32(new_min)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )
