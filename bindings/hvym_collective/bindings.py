# This file was generated by stellar_contract_bindings v0.5.0b0 and stellar_sdk v13.0.0.

from __future__ import annotations

from enum import IntEnum, Enum
from typing import Dict, List, Tuple, Optional, Union

from stellar_sdk import scval, xdr, Address, MuxedAccount, Keypair
from stellar_sdk.contract import AssembledTransaction, ContractClient
from stellar_sdk.contract import AssembledTransactionAsync, ContractClientAsync

NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"


class DatakeyKind(Enum):
    Member = "Member"
    Collective = "Collective"
    Admin = "Admin"
    AdminList = "AdminList"


class Datakey:
    def __init__(
        self,
        kind: DatakeyKind,
        member: Optional[Union[Address, str]] = None,
    ):
        self.kind = kind
        self.member = member

    def to_scval(self) -> xdr.SCVal:
        if self.kind == DatakeyKind.Member:
            assert self.member is not None
            return scval.to_enum(self.kind.name, scval.to_address(self.member))
        if self.kind == DatakeyKind.Collective:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DatakeyKind.Admin:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DatakeyKind.AdminList:
            return scval.to_enum(self.kind.name, None)
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = DatakeyKind(elements[0])
        if kind == DatakeyKind.Member:
            assert elements[1] is not None and isinstance(elements[1], xdr.SCVal)
            return cls(kind, member=scval.from_address(elements[1]))
        if kind == DatakeyKind.Collective:
            return cls(kind)
        if kind == DatakeyKind.Admin:
            return cls(kind)
        if kind == DatakeyKind.AdminList:
            return cls(kind)
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Datakey):
            return NotImplemented
        if self.kind != other.kind:
            return False
        if self.kind == DatakeyKind.Member:
            return self.member == other.member
        return True

    def __hash__(self) -> int:
        if self.kind == DatakeyKind.Member:
            return hash((self.kind, self.member))
        return hash(self.kind)


class Member:
    address: Address
    paid: int

    def __init__(self, address: Union[Address, str], paid: int):
        self.address = address
        self.paid = paid

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "address": scval.to_address(self.address),
                "paid": scval.to_uint32(self.paid),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_address(elements["address"]), scval.from_uint32(elements["paid"])
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Member):
            return NotImplemented
        return self.address == other.address and self.paid == other.paid

    def __hash__(self) -> int:
        return hash((self.address, self.paid))


class Collective:
    join_fee: int
    mint_fee: int
    opus_reward: int
    pay_token: Address
    symbol: str

    def __init__(
        self,
        join_fee: int,
        mint_fee: int,
        opus_reward: int,
        pay_token: Union[Address, str],
        symbol: str,
    ):
        self.join_fee = join_fee
        self.mint_fee = mint_fee
        self.opus_reward = opus_reward
        self.pay_token = pay_token
        self.symbol = symbol

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "join_fee": scval.to_uint32(self.join_fee),
                "mint_fee": scval.to_uint32(self.mint_fee),
                "opus_reward": scval.to_uint32(self.opus_reward),
                "pay_token": scval.to_address(self.pay_token),
                "symbol": scval.to_symbol(self.symbol),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_uint32(elements["join_fee"]),
            scval.from_uint32(elements["mint_fee"]),
            scval.from_uint32(elements["opus_reward"]),
            scval.from_address(elements["pay_token"]),
            scval.from_symbol(elements["symbol"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Collective):
            return NotImplemented
        return (
            self.join_fee == other.join_fee
            and self.mint_fee == other.mint_fee
            and self.opus_reward == other.opus_reward
            and self.pay_token == other.pay_token
            and self.symbol == other.symbol
        )

    def __hash__(self) -> int:
        return hash(
            (
                self.join_fee,
                self.mint_fee,
                self.opus_reward,
                self.pay_token,
                self.symbol,
            )
        )


class KindKind(Enum):
    Instance = "Instance"
    Permanent = "Permanent"
    Temporary = "Temporary"


class Kind:
    def __init__(
        self,
        kind: KindKind,
    ):
        self.kind = kind

    def to_scval(self) -> xdr.SCVal:
        if self.kind == KindKind.Instance:
            return scval.to_enum(self.kind.name, None)
        if self.kind == KindKind.Permanent:
            return scval.to_enum(self.kind.name, None)
        if self.kind == KindKind.Temporary:
            return scval.to_enum(self.kind.name, None)
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = KindKind(elements[0])
        if kind == KindKind.Instance:
            return cls(kind)
        if kind == KindKind.Permanent:
            return cls(kind)
        if kind == KindKind.Temporary:
            return cls(kind)
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Kind):
            return NotImplemented
        if self.kind != other.kind:
            return False
        return True

    def __hash__(self) -> int:
        return hash(self.kind)


class Client(ContractClient):
    def fund_contract(
        self,
        caller: Union[Address, str],
        fund_amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "fund_contract",
            [scval.to_address(caller), scval.to_uint32(fund_amount)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def join(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "join",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def withdraw(
        self,
        caller: Union[Address, str],
        recipient: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "withdraw",
            [scval.to_address(caller), scval.to_address(recipient)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[str]:
        return self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def join_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "join_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def mint_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "mint_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def opus_reward(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "opus_reward",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def member_paid(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "member_paid",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def opus_address(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Address]:
        return self.invoke(
            "opus_address",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_member(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_member",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def remove(
        self,
        admin_caller: Union[Address, str],
        member_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "remove",
            [scval.to_address(admin_caller), scval.to_address(member_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def deploy_node_token(
        self,
        caller: Union[Address, str],
        name: bytes,
        descriptor: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Address]:
        return self.invoke(
            "deploy_node_token",
            [
                scval.to_address(caller),
                scval.to_string(name),
                scval.to_string(descriptor),
            ],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def deploy_ipfs_token(
        self,
        caller: Union[Address, str],
        name: bytes,
        ipfs_hash: bytes,
        file_type: bytes,
        gateways: bytes,
        _ipns_hash: Optional[bytes],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[Address]:
        return self.invoke(
            "deploy_ipfs_token",
            [
                scval.to_address(caller),
                scval.to_string(name),
                scval.to_string(ipfs_hash),
                scval.to_string(file_type),
                scval.to_string(gateways),
                (
                    scval.to_string(_ipns_hash)
                    if _ipns_hash is not None
                    else scval.to_void()
                ),
            ],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def publish_file(
        self,
        caller: Union[Address, str],
        publisher: bytes,
        ipfs_hash: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "publish_file",
            [
                scval.to_address(caller),
                scval.to_string(publisher),
                scval.to_string(ipfs_hash),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def publish_encrypted_share(
        self,
        caller: Union[Address, str],
        publisher: bytes,
        recipient: bytes,
        ipfs_hash: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "publish_encrypted_share",
            [
                scval.to_address(caller),
                scval.to_string(publisher),
                scval.to_string(recipient),
                scval.to_string(ipfs_hash),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def set_opus_token(
        self,
        caller: Union[Address, str],
        opus_contract_id: Union[Address, str],
        initial_alloc: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "set_opus_token",
            [
                scval.to_address(caller),
                scval.to_address(opus_contract_id),
                scval.to_uint32(initial_alloc),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_launched(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_launched",
            [],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_join_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "update_join_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_mint_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "update_mint_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def update_opus_reward(
        self,
        caller: Union[Address, str],
        new_reward: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "update_opus_reward",
            [scval.to_address(caller), scval.to_uint32(new_reward)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def add_admin(
        self,
        caller: Union[Address, str],
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "add_admin",
            [scval.to_address(caller), scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def remove_admin(
        self,
        caller: Union[Address, str],
        admin_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "remove_admin",
            [scval.to_address(caller), scval.to_address(admin_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def is_admin(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "is_admin",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_admin_list(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[Address]]:
        return self.invoke(
            "get_admin_list",
            [],
            parse_result_xdr_fn=lambda v: [
                scval.from_address(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )


class ClientAsync(ContractClientAsync):
    async def fund_contract(
        self,
        caller: Union[Address, str],
        fund_amount: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "fund_contract",
            [scval.to_address(caller), scval.to_uint32(fund_amount)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def join(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "join",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def withdraw(
        self,
        caller: Union[Address, str],
        recipient: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "withdraw",
            [scval.to_address(caller), scval.to_address(recipient)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def symbol(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[str]:
        return await self.invoke(
            "symbol",
            [],
            parse_result_xdr_fn=lambda v: scval.from_symbol(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def join_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "join_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def mint_fee(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "mint_fee",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def opus_reward(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "opus_reward",
            [],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def member_paid(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "member_paid",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def opus_address(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Address]:
        return await self.invoke(
            "opus_address",
            [],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_member(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_member",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def remove(
        self,
        admin_caller: Union[Address, str],
        member_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "remove",
            [scval.to_address(admin_caller), scval.to_address(member_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def deploy_node_token(
        self,
        caller: Union[Address, str],
        name: bytes,
        descriptor: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Address]:
        return await self.invoke(
            "deploy_node_token",
            [
                scval.to_address(caller),
                scval.to_string(name),
                scval.to_string(descriptor),
            ],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def deploy_ipfs_token(
        self,
        caller: Union[Address, str],
        name: bytes,
        ipfs_hash: bytes,
        file_type: bytes,
        gateways: bytes,
        _ipns_hash: Optional[bytes],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[Address]:
        return await self.invoke(
            "deploy_ipfs_token",
            [
                scval.to_address(caller),
                scval.to_string(name),
                scval.to_string(ipfs_hash),
                scval.to_string(file_type),
                scval.to_string(gateways),
                (
                    scval.to_string(_ipns_hash)
                    if _ipns_hash is not None
                    else scval.to_void()
                ),
            ],
            parse_result_xdr_fn=lambda v: scval.from_address(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def publish_file(
        self,
        caller: Union[Address, str],
        publisher: bytes,
        ipfs_hash: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "publish_file",
            [
                scval.to_address(caller),
                scval.to_string(publisher),
                scval.to_string(ipfs_hash),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def publish_encrypted_share(
        self,
        caller: Union[Address, str],
        publisher: bytes,
        recipient: bytes,
        ipfs_hash: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "publish_encrypted_share",
            [
                scval.to_address(caller),
                scval.to_string(publisher),
                scval.to_string(recipient),
                scval.to_string(ipfs_hash),
            ],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def set_opus_token(
        self,
        caller: Union[Address, str],
        opus_contract_id: Union[Address, str],
        initial_alloc: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "set_opus_token",
            [
                scval.to_address(caller),
                scval.to_address(opus_contract_id),
                scval.to_uint32(initial_alloc),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_launched(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_launched",
            [],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_join_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "update_join_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_mint_fee(
        self,
        caller: Union[Address, str],
        new_fee: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "update_mint_fee",
            [scval.to_address(caller), scval.to_uint32(new_fee)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def update_opus_reward(
        self,
        caller: Union[Address, str],
        new_reward: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "update_opus_reward",
            [scval.to_address(caller), scval.to_uint32(new_reward)],
            parse_result_xdr_fn=lambda v: scval.from_int128(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def add_admin(
        self,
        caller: Union[Address, str],
        new_admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "add_admin",
            [scval.to_address(caller), scval.to_address(new_admin)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def remove_admin(
        self,
        caller: Union[Address, str],
        admin_to_remove: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "remove_admin",
            [scval.to_address(caller), scval.to_address(admin_to_remove)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def is_admin(
        self,
        caller: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "is_admin",
            [scval.to_address(caller)],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_admin_list(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[Address]]:
        return await self.invoke(
            "get_admin_list",
            [],
            parse_result_xdr_fn=lambda v: [
                scval.from_address(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )
