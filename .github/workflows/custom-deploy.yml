name: Deploy Soroban Contracts

on:
  push:
    tags:
      - 'deploy-v*'

permissions:
  contents: write
  id-token: write

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests

      - name: Install system dependencies for stellar-cli
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libdbus-1-dev \
            pkg-config \
            libusb-1.0-0-dev \
            libftdi1-dev \
            libudev-dev \
            libssl-dev \
            build-essential \
            cmake \
            curl \
            git \
            protobuf-compiler \
            llvm-dev \
            libclang-dev \
            clang

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          components: rustfmt, clippy
          override: true

      - name: Install Stellar CLI
        env:
          PKG_CONFIG_PATH: /usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/local/lib/pkgconfig
          RUSTFLAGS: '-C target-cpu=native'
        run: |
          cargo install --locked --version 22.8.2 stellar-cli --force
          stellar --version

      - name: Install jq
        run: |
          wget https://github.com/jqlang/jq/releases/latest/download/jq-linux-amd64 -O /usr/local/bin/jq
          chmod +x /usr/local/bin/jq

      - name: Extract version and network from tag
        id: extract
        run: |
          TAG_NAME=${{ github.ref_name }}
          if [[ $TAG_NAME =~ ^deploy-v([0-9.]+)-([a-z]+)$ ]]; then
            VERSION=${BASH_REMATCH[1]}
            NETWORK=${BASH_REMATCH[2]}
            echo "VERSION=$VERSION" >> $GITHUB_ENV
            echo "NETWORK=$NETWORK" >> $GITHUB_ENV
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "NETWORK=$NETWORK" >> $GITHUB_OUTPUT
            if [[ ! "$NETWORK" =~ ^(testnet|mainnet|futurenet)$ ]]; then
              echo "Invalid network: $NETWORK. Must be testnet, mainnet, or futurenet"
              exit 1
            fi
          else
            echo "Invalid tag format: $TAG_NAME. Expected deploy-vX.Y.Z-{testnet|mainnet|futurenet}"
            exit 1
          fi

      - name: Debug version and network
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Tag: ${{ github.ref_name }}"
          echo "Version: ${{ env.VERSION }}"
          echo "Network: ${{ env.NETWORK }}"
          echo "Stellar CLI version: $(stellar --version)"

      - name: Create release-wasm directory
        run: mkdir -p release-wasm

      - name: Download release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE="v${{ env.VERSION }}"
          CONTRACTS=(
            "pintheon-ipfs-token"
            "pintheon-node-token"
            "opus-token"
            "hvym-collective"
          )
          echo "Downloading assets for release $RELEASE"
          RELEASE_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE")
          echo "$RELEASE_INFO" > release-wasm/release_info.json
          if [ "$(echo "$RELEASE_INFO" | jq -r '.message // "null"')" = "Not Found" ]; then
            echo "Error: Release $RELEASE not found"
            exit 1
          fi
          ASSET_COUNT=$(echo "$RELEASE_INFO" | jq -r '.assets | length')
          if [ "$ASSET_COUNT" -eq 0 ]; then
            echo "Error: No assets found for release $RELEASE"
            exit 1
          fi
          for CONTRACT in "${CONTRACTS[@]}"; do
            ASSET_URL=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name == \"${CONTRACT}.wasm\") | .url")
            ASSET_NAME=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name == \"${CONTRACT}.wasm\") | .name")
            if [ -z "$ASSET_URL" ]; then
              echo "Error: No WASM asset found for contract $CONTRACT in release $RELEASE"
              exit 1
            fi
            echo "Downloading $ASSET_NAME from $ASSET_URL for contract $CONTRACT"
            curl -s -L -H "Authorization: Bearer $GITHUB_TOKEN" \
                 -H "Accept: application/octet-stream" \
                 "$ASSET_URL" -o "release-wasm/$ASSET_NAME"
          done

      - name: List downloaded WASM files
        run: |
          echo "Listing files in release-wasm/"
          ls -l release-wasm/ || echo "No files found in release-wasm/"
          if [ -z "$(ls -A release-wasm/)" ]; then
            echo "Error: release-wasm/ is empty"
            exit 1
          fi

      - name: Verify WASM file compatibility
        run: |
          shopt -s nullglob
          WASM_FILES=(release-wasm/*.wasm)
          if [ ${#WASM_FILES[@]} -eq 0 ]; then
            echo "Error: No WASM files found in release-wasm/"
            exit 1
          fi
          
          # Initialize debug output file
          echo "{\"wasm_verification\": []}" > debug_output.json
          
          for wasm in "${WASM_FILES[@]}"; do
            echo "Verifying WASM file: $wasm"
            
            # Check if file exists and is not empty
            if [ ! -f "$wasm" ] || [ ! -s "$wasm" ]; then
              echo "Warning: $wasm is missing or empty"
              continue
            fi
            
            # Get file size and basic info
            FILE_SIZE=$(stat -c%s "$wasm")
            FILE_HASH=$(sha256sum "$wasm" | cut -d ' ' -f1)
            
            echo "  - File size: $FILE_SIZE bytes"
            echo "  - SHA256: $FILE_HASH"
            
            # Try to inspect WASM using stellar contract inspect (if available)
            echo "  - Attempting to inspect contract..."
            if stellar contract inspect --wasm "$wasm" > wasm-inspect-output.txt 2>&1; then
              echo "  - Contract inspection successful"
              cat wasm-inspect-output.txt
            else
              echo "  - Contract inspection failed or not supported"
              cat wasm-inspect-output.txt || echo "No output from inspect command"
            fi
            
            # Add to debug output
            echo "    {\"file\": \"$wasm\", \"size\": $FILE_SIZE, \"hash\": \"$FILE_HASH\", \"status\": \"verified\"}" >> debug_output.json
          done
          
          echo "WASM verification completed (non-blocking)"

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Configure deployment arguments
        id: deploy_config
        run: |
          # Create config directory if it doesn't exist
          mkdir -p config
          
          # Check for hvym-collective_args.json in release artifacts (try both locations)
          if [ -f "release-wasm/hvym-collective_args.json" ]; then
            # Found in release-wasm directory
            cp release-wasm/hvym-collective_args.json config/
          elif [ -f "hvym-collective_args.json" ]; then
            # Found in root of release
            cp hvym-collective_args.json config/
          else
            echo "::error::Missing required file: hvym-collective_args.json"
            echo "This file must be included in the release artifacts for cloud deployment"
            echo "Expected location: root or release-wasm/ directory"
            exit 1
          fi
          echo "Using hvym-collective_args.json from release artifacts"
          
          # Verify the required fields exist
          if ! jq -e 'has("admin") and has("token") and has("join_fee") and has("mint_fee") and has("reward")' config/hvym-collective_args.json > /dev/null; then
            echo "::error::Invalid hvym-collective_args.json: Missing required fields"
            echo "Required fields: admin, token, join_fee, mint_fee, reward"
            exit 1
          fi
          
          # Create post-deployment config file
          echo '{
            "fund_amount": 30.0,
            "initial_opus_alloc": 1000.0,
            "enabled": true
          }' > config/hvym-collective_post_deploy_args.json
          
          # Show the configs for debugging
          echo "Deployment arguments:"
          cat config/hvym-collective_args.json
          echo -e "\nPost-deployment configuration:"
          cat config/hvym-collective_post_deploy_args.json

      - name: Set up Stellar CLI with deployer key
        run: |
          # Install Stellar CLI if not already installed
          if ! command -v stellar &> /dev/null; then
            echo "Installing Stellar CLI..."
            curl -sSf https://soroban.stellar.org/install.sh | sh
            echo "$HOME/.local/bin" >> $GITHUB_PATH
          fi
          
          # Add the deployer key to the Stellar CLI config
          echo "Adding deployer key to Stellar CLI..."
          echo "${{ secrets.ACCT_SECRET }}" | stellar keys add deployer --secret-key
          
          # Get the public key for the account
          echo "Retrieving public key..."
          PUBLIC_KEY=$(stellar keys public-key deployer)
          echo "Using deployer account: $PUBLIC_KEY"
          echo "DEPLOYER_ACCOUNT=$PUBLIC_KEY" >> $GITHUB_ENV
          
          # Verify the account is funded (only on testnet)
          if [ "${{ env.NETWORK }}" = "testnet" ]; then
            echo "Funding test account on testnet..."
            stellar keys fund deployer --network testnet || echo "Funding may have failed, continuing..."
          fi
          
      - name: Run XDR Workaround Deployment
        env:
          NETWORK: ${{ env.NETWORK }}
          RPC_URL: https://soroban-testnet.stellar.org
        run: |
          echo "Starting deployment with post-deployment steps..."
          echo "Using deployer account: ${{ env.DEPLOYER_ACCOUNT }}"
          
          # Deploy with the updated args file
          python3 deploy_with_xdr_workaround.py \
            --mode cloud \
            --wasm-dir release-wasm \
            --deployer-account deployer \
            --network "$NETWORK" \
            --rpc-url "$RPC_URL" \
            --post-deploy-config ./config/hvym-collective_post_deploy_args.json
          
          # Save deployment details as an artifact
          if [ -f deployments.json ]; then
            cp deployments.json deployment_details.json
          else
            echo "{\"status\": \"error\", \"message\": \"Deployment failed or deployments.json not created\"}" > deployment_details.json
          fi
          
          # Create a summary of the deployment
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          if [ -f deployments.md ]; then
            cat deployments.md >> $GITHUB_STEP_SUMMARY
          else
            echo "No deployment details available. Check the logs for errors." >> $GITHUB_STEP_SUMMARY
          fi
          
          # Upload deployment details as an artifact
          echo "DEPLOYMENT_DETAILS=deployment_details.json" >> $GITHUB_ENV
          
          echo "Debug output contents:"
          cat debug_output.json

      - name: Upload deployments.md as artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployments-md
          path: deployments.md

      - name: Upload debug output as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-output
          path: debug_output.json
          if-no-files-found: warn

      - name: Update release notes with deployments
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          RELEASE="v${{ env.VERSION }}"
          echo "Updating release notes for $RELEASE"
          RELEASE_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE")
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          CURRENT_BODY=$(echo "$RELEASE_INFO" | jq -r '.body')
          DEPLOYMENTS_MD=$(cat deployments.md)
          NEW_BODY="$CURRENT_BODY\n\n## Deployment Details\n$DEPLOYMENTS_MD"
          curl -s -X PATCH \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID" \
            -d "{\"body\": $(jq -R -s <<< \"$NEW_BODY\")}"