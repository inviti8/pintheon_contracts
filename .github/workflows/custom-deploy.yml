name: Deploy Soroban Contracts

on:
  push:
    tags:
      - 'deploy-*-v*'        # Format: deploy-{release_name}-vX.Y.Z-{network}
      - 'fast-deploy-*-v*'   # Format: fast-deploy-{release_name}-vX.Y.Z-{network}

permissions:
  contents: write
  id-token: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: full
  STELLAR_CLI_VERSION: 23.4.0
  TAG_NAME: ${{ github.ref_name }}
  # Default values that will be set in a setup step
  IS_FAST_DEPLOY: "false"
  RELEASE_NAME: ""
  VERSION: ""

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          # Install specific versions that work well together
          pip install 'stellar-sdk==10.0.0' 'cryptography==41.0.7' requests toml selenium webdriver-manager python-dotenv

      - name: Install system dependencies
        run: |
          # Install required system dependencies
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            wget \
            unzip \
            jq \
            libdbus-1-dev \
            pkg-config \
            libusb-1.0-0-dev \
            libudev-dev \
            libssl-dev \
            build-essential \
            cmake
          
      - name: Install system dependencies for stellar-cli
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libdbus-1-dev \
            pkg-config \
            libusb-1.0-0-dev \
            libftdi1-dev \
            libudev-dev \
            libssl-dev \
            build-essential \
            cmake \
            curl \
            git \
            protobuf-compiler \
            llvm-dev \
            libclang-dev \
            clang

      - name: Set up environment variables
        id: set_env
        run: |
          # Set IS_FAST_DEPLOY
          if [[ ${{ github.ref }} == refs/tags/fast-deploy-* ]]; then
            echo "IS_FAST_DEPLOY=true" >> $GITHUB_ENV
            
            # For fast-deploy-{release_name}-vX.Y.Z-{network}
            TAG_PREFIX=${GITHUB_REF_NAME#fast-deploy-}
            RELEASE_NAME=${TAG_PREFIX%%-v*}
            VERSION_WITH_NETWORK=${GITHUB_REF_NAME##*-v}
            VERSION=${VERSION_WITH_NETWORK%-*}
            NETWORK=${GITHUB_REF_NAME##*-}
          else
            # For deploy-{release_name}-vX.Y.Z-{network}
            echo "IS_FAST_DEPLOY=false" >> $GITHUB_ENV
            TAG_PREFIX=${GITHUB_REF_NAME#deploy-}
            RELEASE_NAME=${TAG_PREFIX%%-v*}
            VERSION_WITH_NETWORK=${GITHUB_REF_NAME##*-v}
            VERSION=${VERSION_WITH_NETWORK%-*}
            NETWORK=${GITHUB_REF_NAME##*-}
          fi
          
          echo "RELEASE_NAME=$RELEASE_NAME" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "NETWORK=$NETWORK" >> $GITHUB_ENV
          
          # Debug output
          echo "Release name: $RELEASE_NAME"
          echo "Version: $VERSION"
          echo "Network: $NETWORK"
          echo "Is fast deploy: $IS_FAST_DEPLOY"

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          components: rustfmt, clippy
          override: true


      - name: Install Stellar CLI (Standard Build)
        if: env.IS_FAST_DEPLOY == 'false'
        env:
          PKG_CONFIG_PATH: /usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/local/lib/pkgconfig
          RUSTFLAGS: '-C target-cpu=native'
        run: |
          echo "Installing Stellar CLI from source..."
          cargo install --locked --version ${{ env.STELLAR_CLI_VERSION }} stellar-cli --force
          stellar --version

      - name: Install Stellar CLI (Fast Build)
        if: env.IS_FAST_DEPLOY == 'true'
        run: |
          echo "Downloading pre-built Stellar CLI..."
          VERSION=${{ env.STELLAR_CLI_VERSION }}
          
          # Download the pre-built binary
          curl -L -o stellar-cli.tar.gz \
            "https://github.com/stellar/stellar-cli/releases/download/v${VERSION}/stellar-cli-${VERSION}-x86_64-unknown-linux-gnu.tar.gz"
          
          # Extract the binary
          tar -xzf stellar-cli.tar.gz
          
          # Make it executable and move to PATH
          chmod +x stellar
          sudo mv stellar /usr/local/bin/
          
          # Verify installation
          echo "Stellar CLI version:"
          stellar --version
          
          # Clean up
          rm -f stellar-cli.tar.gz

      - name: Create wasm directory
        run: mkdir -p wasm

      - name: Download release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ env.VERSION }}"
          CONTRACTS=(
            "pintheon_ipfs_token"
            "pintheon_node_token"
            "opus_token"
            "hvym_collective"
            "hvym_roster"
            "hvym_pin_service"
          )
          
          # Fetch all releases and find the latest one matching the version
          echo "Fetching releases to find the latest for version '$VERSION'..."
          RELEASES_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases")

          # Filter releases for the correct tag (e.g., 0.00) and find the most recent
          LATEST_RELEASE_INFO=$(echo "$RELEASES_INFO" | jq -r --arg VERSION "$VERSION" '[
            .[] | select(.tag_name == $VERSION)
          ] | sort_by(.created_at) | .[-1] // null')

          if [ -z "$LATEST_RELEASE_INFO" ] || [ "$LATEST_RELEASE_INFO" == "null" ]; then
            echo "::error::No release found for version '$VERSION'."
            exit 1
          fi

          RELEASE_TAG=$(echo "$LATEST_RELEASE_INFO" | jq -r '.tag_name')
          echo "Found latest release for version '$VERSION' with tag: $RELEASE_TAG"
          echo "$LATEST_RELEASE_INFO" > wasm/release_info.json

          # Download all contract wasm files from the latest release
          for CONTRACT in "${CONTRACTS[@]}"; do
            # Try both optimized and non-optimized filenames
            for SUFFIX in ".optimized.wasm" ".wasm"; do
              WASM_FILE="${CONTRACT}${SUFFIX}"
              ASSET_URL=$(echo "$LATEST_RELEASE_INFO" | jq -r --arg WASM_FILE "$WASM_FILE" '.assets[] | select(.name == $WASM_FILE) | .url')
              if [ -n "$ASSET_URL" ]; then
                OUTPUT_FILE="wasm/$(basename "$WASM_FILE")"
                echo "Downloading $WASM_FILE from release $RELEASE_TAG..."
                curl -s -L -H "Authorization: Bearer $GITHUB_TOKEN" \
                     -H "Accept: application/octet-stream" \
                     "$ASSET_URL" -o "$OUTPUT_FILE"
                break # Move to the next contract
              fi
            done
          done

          # Verify all required files were downloaded
          for CONTRACT in "${CONTRACTS[@]}"; do
            if [ ! -f "wasm/${CONTRACT}.wasm" ] && [ ! -f "wasm/${CONTRACT}.optimized.wasm" ]; then
              echo "::error::Failed to download WASM for contract '${CONTRACT}' from release '$RELEASE_TAG'."
              exit 1
            fi
          done

          echo "All required WASM files downloaded successfully."

      - name: List downloaded WASM files
        run: |
          echo "Listing files in wasm/"
          ls -l wasm/ || echo "No files found in wasm/"
          if [ -z "$(ls -A wasm/)" ]; then
            echo "Error: wasm/ is empty"
            exit 1
          fi

      - name: Verify WASM files
        run: |
          # Verify each WASM file exists and is not empty
          for wasm_file in wasm/*.wasm; do
            echo "Verifying $wasm_file"
            if [ ! -s "$wasm_file" ]; then
              echo "::error::WASM file $wasm_file is missing or empty"
              exit 1
            fi
            
            # Basic WASM verification
            if ! wasm-opt --version > /dev/null 2>&1; then
              echo "Skipping wasm-opt validation (not installed)"
            elif ! wasm-opt "$wasm_file" -o /dev/null; then
              echo "::warning::WASM file $wasm_file failed wasm-opt validation"
            else
              echo "$wasm_file passed basic validation"
            fi
          done

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Configure deployment arguments
        id: deploy_config
        run: |
          # Show the configs for debugging
          echo "Deployment arguments:"
          cat hvym_collective_args.json
          echo -e "\nPost-deployment configuration:"
          cat hvym_collective_post_deploy_args.json

      - name: Set up Stellar deployer identity
        id: setup_identity
        run: |
          # Install required Python packages
          python -m pip install stellar-sdk toml
          
          # Run the setup script
          echo "ðŸ”§ Setting up Stellar deployer identity for network: ${{ env.NETWORK }}"
          echo "Working directory: $(pwd)"
          
          python setup_deployer_identity.py \
            --secret-key-env ACCT_SECRET \
            --network ${{ env.NETWORK }} \
            --rpc-url https://soroban-testnet.stellar.org
          
          # Get the identity name for subsequent steps
          IDENTITY_NAME="${{ env.NETWORK }}_DEPLOYER"
          IDENTITY_NAME=$(echo "$IDENTITY_NAME" | tr '[:lower:]' '[:upper:]')
          
          # Save identity name for subsequent steps
          echo "IDENTITY_NAME=$IDENTITY_NAME" >> $GITHUB_ENV
          
          # Get public key from the TOML file
          if [ ! -f ".stellar/identity/${IDENTITY_NAME}.toml" ]; then
            echo "::error::Identity file not found: .stellar/identity/${IDENTITY_NAME}.toml"
            exit 1
          fi
          
          PUBLIC_KEY=$(python -c "import toml; print(toml.load(open('.stellar/identity/${IDENTITY_NAME}.toml'))['public_key'])")
          if [ $? -ne 0 ]; then
            echo "::error::Failed to read public key from identity file"
            exit 1
          fi
          
          echo "PUBLIC_KEY=$PUBLIC_KEY" >> $GITHUB_ENV
          
          echo "âœ… Identity setup complete"
          echo "   Identity: $IDENTITY_NAME"
          echo "   Public key: $PUBLIC_KEY"
        env:
          ACCT_SECRET: ${{ secrets.ACCT_SECRET }}
          
      - name: Run deployment script
        env:
          NETWORK: ${{ env.NETWORK }}
          RPC_URL: https://soroban-testnet.stellar.org
          STELLAR_NETWORK: ${{ env.NETWORK }}
          STELLAR_RPC_URL: https://soroban-testnet.stellar.org
          STELLAR_HOME: ${{ github.workspace }}/.stellar
          XDG_CONFIG_HOME: ${{ github.workspace }}/.stellar
        run: |
          # Ensure we're in the repository root
          cd "$GITHUB_WORKSPACE"
          
          echo "Running deployment for ${{ env.NETWORK }} in $(pwd)"
          
          # Verify we're in the correct directory by checking for important files
          if [ ! -f "deploy_contracts.py" ] || [ ! -d ".github/workflows" ]; then
            echo "::error::Not in repository root directory. Current directory: $(pwd)"
            exit 1
          fi
          
          # Get the identity name based on network (already verified in setup step)
          IDENTITY_NAME="testnet_DEPLOYER"
          IDENTITY_NAME=$(echo "$IDENTITY_NAME" | tr '[:lower:]' '[:upper:]')
  
          # Use the public key from the environment (already verified in setup step)
          DEPLOYER_PUBLIC_KEY="$PUBLIC_KEY"
          echo "ðŸš€ Starting deployment with identity: $IDENTITY_NAME"
          echo "   Public key: $DEPLOYER_PUBLIC_KEY"
          
          # Ensure the wasm directory exists
          if [ ! -d "wasm" ]; then
            echo "::error::WASM directory not found. Make sure contracts are built."
            exit 1
          fi
          
          # Ensure the config directory exists
          mkdir -p config
          
          # Run the deployment script with the correct identity name and exit on failure
          if ! python deploy_contracts.py \
            --deployer-acct "$IDENTITY_NAME" \
            --network "${{ env.NETWORK }}" \
            --wasm-dir wasm; then
            echo "::error::deploy_contracts.py script failed."
            exit 1
          fi
          
          # Save deployment details as an artifact with release information
          if [ -f deployments.json ]; then
            # Add release info to deployments.json
            jq --arg release "${{ env.RELEASE_NAME }}" --arg version "${{ env.VERSION }}" \
              '. + {release: $release, version: $version}' deployments.json > deployment_details.json
            mv deployment_details.json deployments.json  # Update original file too
            cp deployments.json deployment_details.json  # Create a copy for the artifact
          else
            echo "{\"status\": \"error\", \"message\": \"Deployment failed or deployments.json not created\", \"release\": \"${{ env.RELEASE_NAME }}\", \"version\": \"${{ env.VERSION }}\"}" > deployment_details.json
          fi
          
          # Create a summary of the deployment
          echo "## ðŸš€ ${{ env.RELEASE_NAME }} Deployment Summary (v${{ env.VERSION }})" >> $GITHUB_STEP_SUMMARY
          echo "### Release Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Name**: ${{ env.RELEASE_NAME}}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ env.VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Type**: ${{ env.IS_FAST_DEPLOY == 'true' && 'Fast' || 'Standard' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
          if [ -f deployments.md ]; then
            cat deployments.md >> $GITHUB_STEP_SUMMARY
          else
            echo "No deployment details available. Check the logs for errors." >> $GITHUB_STEP_SUMMARY
          fi
          
          # Upload deployment details as an artifact
          echo "DEPLOYMENT_DETAILS=deployment_details.json" >> $GITHUB_ENV
          
      - name: Run post-deployment actions for hvym-collective
        if: success()
        env:
          STELLAR_HOME: ${{ github.workspace }}/.stellar
          XDG_CONFIG_HOME: ${{ github.workspace }}/.stellar
          NETWORK: ${{ env.NETWORK }}
          IDENTITY_NAME: ${{ env.IDENTITY_NAME }}
          PUBLIC_KEY: ${{ env.PUBLIC_KEY }}
        run: |
          # Check if post-deployment is enabled
          if [ -f "hvym_collective_post_deploy_args.json" ]; then
            ENABLED=$(jq -r '.enabled // true' hvym_collective_post_deploy_args.json)
            if [ "$ENABLED" = "true" ]; then
              echo "Running post-deployment actions for hvym-collective..."
              
              # Get deployment arguments
              FUND_AMOUNT=$(jq -r '.fund_amount // 30' hvym_collective_post_deploy_args.json)
              INITIAL_OPUS_ALLOC=$(jq -r '.initial_opus_alloc // 1000' hvym_collective_post_deploy_args.json)
              
              # Run post-deployment script
              python hvym_post_deploy.py \
                --deployer-acct "$IDENTITY_NAME" \
                --network "$NETWORK" \
                --fund-amount "$FUND_AMOUNT" \
                --initial-opus-alloc "$INITIAL_OPUS_ALLOC"
                
              echo "âœ… Post-deployment actions completed successfully"
            else
              echo "â„¹ï¸ Post-deployment actions are disabled in hvym_collective_post_deploy_args.json"
            fi
          else
            echo "â„¹ï¸ No post-deployment configuration found, using defaults"
            python hvym_post_deploy.py \
              --deployer-acct "$IDENTITY_NAME" \
              --deployer-pubkey "$PUBLIC_KEY" \
              --network "$NETWORK" \
              --fund-amount 30 \
              --initial-opus-alloc 1000
          fi

      - name: Submit to Stellar Expert
        if: success()
        run: |
          echo "ðŸŒ Submitting to Stellar Expert..."
          
          # Create a clean copy of deployments.json for processing
          if [ ! -f "deployments.json" ]; then
            echo "Error: deployments.json not found"
            exit 0
          fi
          
          # Create a clean copy and validate JSON
          CLEAN_DEPLOYMENTS="clean_deployments.json"
          jq '.' deployments.json > "$CLEAN_DEPLOYMENTS" || {
            echo "Error: Invalid JSON in deployments.json"
            jq -c . deployments.json | head -n 5  # Show first 5 lines for debugging
            exit 1
          }
          
          # Get list of contracts, filtering out metadata fields
          CONTRACTS=$(jq -r 'keys[] | select(. != "network" and . != "timestamp" and . != "cli_version" and . != "note" and . != "release" and . != "version")' "$CLEAN_DEPLOYMENTS")
          
          if [ -z "$CONTRACTS" ]; then
            echo "No valid contracts found in deployments.json"
            exit 0
          fi
          
          echo "Found contracts: $CONTRACTS"
          
          for CONTRACT in $CONTRACTS; do
            # Use jq to safely extract values
            CONTRACT_DATA=$(jq -r ".[\"$CONTRACT\"]" "$CLEAN_DEPLOYMENTS")
            WASM_HASH=$(echo "$CONTRACT_DATA" | jq -r '.wasm_hash // empty')
            CONTRACT_ID=$(echo "$CONTRACT_DATA" | jq -r '.contract_id // empty')
            
            if [ -n "$WASM_HASH" ] && [ -n "$CONTRACT_ID" ]; then
              echo "\n=== Submitting $CONTRACT ==="
              echo "Contract ID: $CONTRACT_ID"
              echo "WASM Hash: $WASM_HASH"
              
              # Submit to Stellar Expert with proper error handling
              RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
                "https://api.stellar.expert/explorer/public/contract-validation/match" \
                -H "Content-Type: application/json" \
                -d '{
                  "repository": "${{ github.repository }}",
                  "commitHash": "${{ github.sha }}",
                  "jobId": "${{ github.job }}",
                  "runId": "${{ github.run_id }}",
                  "contractHash": "'$WASM_HASH'",
                  "contractId": "'$CONTRACT_ID'",
                  "packageName": "'$CONTRACT'",
                  "network": "'${{ env.NETWORK}}'",
                  "makeTarget": "deploy"
                }')
              
              HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
              RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
              
              echo "Status: $HTTP_STATUS"
              echo "Response: $RESPONSE_BODY"
              
              if [ "$HTTP_STATUS" != "200" ]; then
                echo "::warning::Failed to submit $CONTRACT to Stellar Expert"
              fi
            else
              echo "Skipping $CONTRACT - missing wasm_hash or contract_id"
            fi
          done
          
      - name: Upload deployments.md as artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployments-md
          path: deployments.md

      - name: Update release notes with deployments
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Construct the full tag name from environment variables
          if [[ "${{ env.IS_FAST_DEPLOY }}" == "true" ]]; then
            FULL_TAG="fast-deploy-${{ env.RELEASE_NAME }}-v${{ env.VERSION }}-${{ env.NETWORK }}"
          else
            FULL_TAG="deploy-${{ env.RELEASE_NAME }}-v${{ env.VERSION }}-${{ env.NETWORK }}"
          fi
          echo "Full tag for release lookup: $FULL_TAG"
          # Get the release info using the full tag name
          RELEASE_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$FULL_TAG")
            
          # Check if we got a valid response
          if [ "$(echo "$RELEASE_INFO" | jq -r '.message')" = "Not Found" ]; then
            echo "Error: Release $FULL_TAG not found"
            exit 1
          fi
          
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          CURRENT_BODY=$(echo "$RELEASE_INFO" | jq -r '.body // ""')
          
          echo "Current release ID: $RELEASE_ID"
          echo "Current body length: ${#CURRENT_BODY} characters"
          
          # Read the deployments markdown
          if [ -f "deployments.md" ]; then
            DEPLOYMENTS_MD=$(cat deployments.md)
            echo "Read deployments.md (${#DEPLOYMENTS_MD} characters)"
            
            # Prepare the new body - ensure we don't duplicate the deployment details
            if [[ "$CURRENT_BODY" == *"## Deployment Details"* ]]; then
              echo "Found existing Deployment Details section, replacing it"
              NEW_BODY="${CURRENT_BODY%%## Deployment Details*}## Deployment Details\n\n$DEPLOYMENTS_MD"
            else
              NEW_BODY="${CURRENT_BODY}\n\n## Deployment Details\n\n$DEPLOYMENTS_MD"
            fi
            
            # Update the release
            echo "Updating release with new body (${#NEW_BODY} characters)"
            
            # Use jq to properly escape the JSON
            JSON_PAYLOAD=$(jq -n --arg body "$NEW_BODY" '{"body": $body}')
            
            # Debug output
            echo "JSON payload length: ${#JSON_PAYLOAD}"
            
            # Make the API call
            RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID" \
              -d "$JSON_PAYLOAD")
              
            # Split response into body and status code
            HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
            RESPONSE_BODY=$(echo "$RESPONSE" | jq -r '.' 2>/dev/null || echo "$RESPONSE" | head -n -1)
            
            echo "GitHub API response status: $HTTP_STATUS"
            if [ $HTTP_STATUS -ne 200 ]; then
              echo "Error updating release notes:"
              echo "$RESPONSE_BODY"
              exit 1
            fi
            
            echo "âœ… Successfully updated release notes"
          else
            echo "Error: deployments.md not found"
            exit 1
          fi