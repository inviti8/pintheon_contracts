name: Deploy Soroban Contracts

on:
  push:
    tags:
      - 'deploy-v*'       # Standard build (builds CLI from source), format: deploy-vX.Y.Z-{testnet|mainnet|futurenet}
      - 'fast-deploy-v*'  # Fast build (downloads pre-built binary), format: fast-deploy-vX.Y.Z-{testnet|mainnet|futurenet}

permissions:
  contents: write
  id-token: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: full
  STELLAR_CLI_VERSION: 23.0.1

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          # Install specific versions that work well together
          pip install 'stellar-sdk==10.0.0' 'cryptography==41.0.7' requests toml selenium webdriver-manager python-dotenv

      - name: Install system dependencies
        run: |
          # Install required system dependencies
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            wget \
            unzip \
            jq \
            libdbus-1-dev \
            pkg-config \
            libusb-1.0-0-dev \
            libudev-dev \
            libssl-dev \
            build-essential \
            cmake
          
      - name: Install system dependencies for stellar-cli
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libdbus-1-dev \
            pkg-config \
            libusb-1.0-0-dev \
            libftdi1-dev \
            libudev-dev \
            libssl-dev \
            build-essential \
            cmake \
            curl \
            git \
            protobuf-compiler \
            llvm-dev \
            libclang-dev \
            clang

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          components: rustfmt, clippy
          override: true

      - name: Determine build type
        id: build_type
        run: |
          if [[ ${{ github.ref_name }} == fast-* ]]; then
            echo "BUILD_TYPE=fast" >> $GITHUB_ENV
            echo "::set-output name=type::fast"
          else
            echo "BUILD_TYPE=standard" >> $GITHUB_ENV
            echo "::set-output name=type::standard"
          fi
          echo "Build type: ${{ env.BUILD_TYPE }}"

      - name: Install Stellar CLI (Standard Build)
        if: env.BUILD_TYPE == 'standard'
        env:
          PKG_CONFIG_PATH: /usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/local/lib/pkgconfig
          RUSTFLAGS: '-C target-cpu=native'
        run: |
          echo "Installing Stellar CLI from source..."
          cargo install --locked --version ${{ env.STELLAR_CLI_VERSION }} stellar-cli --force
          stellar --version

      - name: Install Stellar CLI (Fast Build)
        if: env.BUILD_TYPE == 'fast'
        run: |
          echo "Downloading pre-built Stellar CLI..."
          VERSION=${{ env.STELLAR_CLI_VERSION }}
          
          # Download the pre-built binary
          curl -L -o stellar-cli.tar.gz \
            "https://github.com/stellar/stellar-cli/releases/download/v${VERSION}/stellar-cli-${VERSION}-x86_64-unknown-linux-gnu.tar.gz"
          
          # Extract the binary
          tar -xzf stellar-cli.tar.gz
          
          # Make it executable and move to PATH
          chmod +x stellar
          sudo mv stellar /usr/local/bin/
          
          # Verify installation
          echo "Stellar CLI version:"
          stellar --version
          
          # Clean up
          rm -f stellar-cli.tar.gz

      - name: Extract version and network from tag
        id: extract
        run: |
          TAG_NAME=${{ github.ref_name }}
          if [[ $TAG_NAME =~ ^(fast-)?deploy-v([0-9.]+)-([a-z]+)$ ]]; then
            VERSION=${BASH_REMATCH[2]}
            NETWORK=${BASH_REMATCH[3]}
            echo "VERSION=$VERSION" >> $GITHUB_ENV
            echo "NETWORK=$NETWORK" >> $GITHUB_ENV
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "NETWORK=$NETWORK" >> $GITHUB_OUTPUT
            if [[ ! "$NETWORK" =~ ^(testnet|mainnet|futurenet)$ ]]; then
              echo "Invalid network: $NETWORK. Must be testnet, mainnet, or futurenet"
              exit 1
            fi
            
            # Set BUILD_TYPE based on tag prefix
            if [[ ${BASH_REMATCH[1]} == "fast-" ]]; then
              echo "BUILD_TYPE=fast" >> $GITHUB_ENV
            else
              echo "BUILD_TYPE=standard" >> $GITHUB_ENV
            fi
          else
            echo "Invalid tag format: $TAG_NAME. Expected [fast-]deploy-vX.Y.Z-{testnet|mainnet|futurenet}"
            exit 1
          fi

      - name: Debug version and network
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Tag: ${{ github.ref_name }}"
          echo "Version: ${{ env.VERSION }}"
          echo "Network: ${{ env.NETWORK }}"
          echo "Stellar CLI version: $(stellar --version)"

      - name: Create wasm directory
        run: mkdir -p wasm

      - name: Download release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ env.VERSION }}"
          CONTRACTS=(
            "pintheon_ipfs_token"
            "pintheon_node_token"
            "opus_token"
            "hvym_collective"
          )
          
          # Try both fast-vX.XX and vX.XX formats
          RELEASE_TAGS=("v$VERSION" "fast-v$VERSION")
          
          for RELEASE_TAG in "${RELEASE_TAGS[@]}"; do
            echo "Trying release tag: $RELEASE_TAG"
            RELEASE_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
              "https://api.github.com/repos/${{ github.repository }}/releases/tags/$RELEASE_TAG" 2>/dev/null)
              
            # Check if release exists and has assets
            if [ "$(echo "$RELEASE_INFO" | jq -r '.message // "success"')" != "Not Found" ]; then
              ASSET_COUNT=$(echo "$RELEASE_INFO" | jq -r '.assets | length // 0')
              if [ "$ASSET_COUNT" -gt 0 ]; then
                echo "Found release with $ASSET_COUNT assets at tag: $RELEASE_TAG"
                echo "$RELEASE_INFO" > wasm/release_info.json
                
                # Download all contract wasm files
                for CONTRACT in "${CONTRACTS[@]}"; do
                  # Try both optimized and non-optimized filenames
                  for SUFFIX in ".optimized.wasm" ".wasm"; do
                    WASM_FILE="${CONTRACT}${SUFFIX}"
                    ASSET_URL=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name == \"$WASM_FILE\") | .url")
                    if [ -n "$ASSET_URL" ]; then
                      # Preserve the original filename including .optimized.wasm
                      OUTPUT_FILE="wasm/$(basename "$WASM_FILE")"
                      echo "Downloading $WASM_FILE from $RELEASE_TAG as $OUTPUT_FILE"
                      curl -s -L -H "Authorization: Bearer $GITHUB_TOKEN" \
                           -H "Accept: application/octet-stream" \
                           "$ASSET_URL" -o "$OUTPUT_FILE"
                      break  # Found the file, move to next contract
                    fi
                  done
                  
                  if [ ! -f "wasm/${CONTRACT}.wasm" ] && [ ! -f "wasm/${CONTRACT}.optimized.wasm" ]; then
                    echo "Warning: Neither ${CONTRACT}.wasm nor ${CONTRACT}.optimized.wasm found in release $RELEASE_TAG"
                  fi
                done
                
                # Verify we got all required files
                ALL_FOUND=true
                for CONTRACT in "${CONTRACTS[@]}"; do
                  if [ ! -f "wasm/${CONTRACT}.wasm" ] && [ ! -f "wasm/${CONTRACT}.optimized.wasm" ]; then
                    echo "Error: Neither ${CONTRACT}.wasm nor ${CONTRACT}.optimized.wasm found in release $RELEASE_TAG"
                    ALL_FOUND=false
                  fi
                done
                
                if [ "$ALL_FOUND" = true ]; then
                  echo "Successfully downloaded all contract wasm files from $RELEASE_TAG"
                  exit 0
                else
                  echo "Some contract wasm files missing from $RELEASE_TAG, trying next tag..."
                  # Clear any partially downloaded files
                  rm -f wasm/*.wasm
                fi
              fi
            fi
          done
          
          # If we get here, we failed to find a suitable release
          echo "Error: Failed to find a release with all required contract wasm files"
          echo "Tried tags: ${RELEASE_TAGS[*]}"
          exit 1

      - name: List downloaded WASM files
        run: |
          echo "Listing files in wasm/"
          ls -l wasm/ || echo "No files found in wasm/"
          if [ -z "$(ls -A wasm/)" ]; then
            echo "Error: wasm/ is empty"
            exit 1
          fi

      - name: Verify WASM files
        run: |
          # Verify each WASM file exists and is not empty
          for wasm_file in wasm/*.wasm; do
            echo "Verifying $wasm_file"
            if [ ! -s "$wasm_file" ]; then
              echo "::error::WASM file $wasm_file is missing or empty"
              exit 1
            fi
            
            # Basic WASM verification
            if ! wasm-opt --version > /dev/null 2>&1; then
              echo "Skipping wasm-opt validation (not installed)"
            elif ! wasm-opt "$wasm_file" -o /dev/null; then
              echo "::warning::WASM file $wasm_file failed wasm-opt validation"
            else
              echo "$wasm_file passed basic validation"
            fi
          done

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Configure deployment arguments
        id: deploy_config
        run: |
          # Create config directory if it doesn't exist
          mkdir -p config
          
          # Check for hvym-collective_args.json in release artifacts (try both locations)
          if [ -f "wasm/hvym-collective_args.json" ]; then
            # Found in wasm directory
            cp wasm/hvym-collective_args.json config/
          elif [ -f "hvym-collective_args.json" ]; then
            # Found in root of release
            cp hvym-collective_args.json config/
          else
            echo "::error::Missing required file: hvym-collective_args.json"
            echo "This file must be included in the release artifacts for cloud deployment"
            echo "Expected location: root or wasm/ directory"
            exit 1
          fi
          echo "Using hvym-collective_args.json from release artifacts"
          
          # Verify the required fields exist
          if ! jq -e 'has("admin") and has("token") and has("join_fee") and has("mint_fee") and has("reward")' config/hvym-collective_args.json > /dev/null; then
            echo "::error::Invalid hvym-collective_args.json: Missing required fields"
            echo "Required fields: admin, token, join_fee, mint_fee, reward"
            exit 1
          fi
          
          # Create post-deployment config file
          echo '{
            "fund_amount": 30.0,
            "initial_opus_alloc": 1000.0,
            "enabled": true
          }' > config/hvym-collective_post_deploy_args.json
          
          # Show the configs for debugging
          echo "Deployment arguments:"
          cat config/hvym-collective_args.json
          echo -e "\nPost-deployment configuration:"
          cat config/hvym-collective_post_deploy_args.json

      - name: Set up Stellar deployer identity
        id: setup_identity
        run: |
          # Install required Python packages
          python -m pip install stellar-sdk toml
          
          # Run the setup script
          echo "ðŸ”§ Setting up Stellar deployer identity for network: ${{ env.NETWORK }}"
          echo "Working directory: $(pwd)"
          
          python setup_deployer_identity.py \
            --secret-key-env ACCT_SECRET \
            --network ${{ env.NETWORK }} \
            --rpc-url https://soroban-testnet.stellar.org
            
          # Verify the identity is usable
          echo "ðŸ” Verifying identity is usable..."
          IDENTITY_NAME="${{ env.NETWORK }}_DEPLOYER"
          IDENTITY_NAME=$(echo "$IDENTITY_NAME" | tr '[:lower:]' '[:upper:]')
          
          # Get public key from identity
          PUBLIC_KEY=$(stellar keys public-key "$IDENTITY_NAME" 2>&1)
          if [ $? -ne 0 ]; then
            echo "::error::Failed to get public key from identity: $PUBLIC_KEY"
            exit 1
          fi
          
          echo "âœ… Identity setup complete"
          echo "   Identity: $IDENTITY_NAME"
          echo "   Public Key: $PUBLIC_KEY"
        env:
          ACCT_SECRET: ${{ secrets.ACCT_SECRET }}
          
      - name: Run deployment script
        env:
          NETWORK: ${{ env.NETWORK }}
          RPC_URL: https://soroban-testnet.stellar.org
          STELLAR_NETWORK: ${{ env.NETWORK }}
          STELLAR_RPC_URL: https://soroban-testnet.stellar.org
        run: |
          # Ensure we're in the repository root
          cd "$GITHUB_WORKSPACE"
          
          echo "Running deployment for ${{ env.NETWORK }} in $(pwd)"
          
          # Verify we're in the correct directory by checking for important files
          if [ ! -f "deploy_contracts.py" ] || [ ! -d ".github/workflows" ]; then
            echo "::error::Not in repository root directory. Current directory: $(pwd)"
            exit 1
          fi
          
          # Get the identity name based on network (already verified in setup step)
          IDENTITY_NAME="${{ env.NETWORK }}_DEPLOYER"
          IDENTITY_NAME=$(echo "$IDENTITY_NAME" | tr '[:lower:]' '[:upper:]')
          
          # Get the deployer's public key (already verified in setup step)
          DEPLOYER_PUBLIC_KEY=$(stellar keys public-key "$IDENTITY_NAME")
          echo "ðŸš€ Starting deployment with identity: $IDENTITY_NAME"
          echo "   Public key: $DEPLOYER_PUBLIC_KEY"
          
          # Ensure the wasm directory exists
          if [ ! -d "wasm" ]; then
            echo "::error::WASM directory not found. Make sure contracts are built."
            exit 1
          fi
          
          # Ensure the config directory exists
          mkdir -p config
          
          # Run the deployment script with the correct identity name
          python deploy_contracts.py \
            --deployer-acct "$IDENTITY_NAME" \
            --network "${{ env.NETWORK }}" \
            --wasm-dir wasm
          
          # Save deployment details as an artifact
          if [ -f deployments.json ]; then
            cp deployments.json deployment_details.json
          else
            echo "{\"status\": \"error\", \"message\": \"Deployment failed or deployments.json not created\"}" > deployment_details.json
          fi
          
          # Create a summary of the deployment
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          if [ -f deployments.md ]; then
            cat deployments.md >> $GITHUB_STEP_SUMMARY
          else
            echo "No deployment details available. Check the logs for errors." >> $GITHUB_STEP_SUMMARY
          fi
          
          # Upload deployment details as an artifact
          echo "DEPLOYMENT_DETAILS=deployment_details.json" >> $GITHUB_ENV
          
          echo "Debug output contents:"
          cat debug_output.json

      - name: Upload deployments.md as artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployments-md
          path: deployments.md

      - name: Upload debug output as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-output
          path: debug_output.json
          if-no-files-found: warn

      - name: Update release notes with deployments
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the full tag name (e.g., deploy-v0.03-testnet)
          FULL_TAG="${{ github.ref_name}}"
          echo "Updating release notes for tag: $FULL_TAG"
          
          # Get the release info using the full tag name
          RELEASE_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$FULL_TAG")
            
          # Check if we got a valid response
          if [ "$(echo "$RELEASE_INFO" | jq -r '.message')" = "Not Found" ]; then
            echo "Error: Release $FULL_TAG not found"
            exit 1
          fi
          
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          CURRENT_BODY=$(echo "$RELEASE_INFO" | jq -r '.body // ""')
          
          echo "Current release ID: $RELEASE_ID"
          echo "Current body length: ${#CURRENT_BODY} characters"
          
          # Read the deployments markdown
          if [ -f "deployments.md" ]; then
            DEPLOYMENTS_MD=$(cat deployments.md)
            echo "Read deployments.md (${#DEPLOYMENTS_MD} characters)"
            
            # Prepare the new body - ensure we don't duplicate the deployment details
            if [[ "$CURRENT_BODY" == *"## Deployment Details"* ]]; then
              echo "Found existing Deployment Details section, replacing it"
              NEW_BODY="${CURRENT_BODY%%## Deployment Details*}## Deployment Details\n\n$DEPLOYMENTS_MD"
            else
              NEW_BODY="${CURRENT_BODY}\n\n## Deployment Details\n\n$DEPLOYMENTS_MD"
            fi
            
            # Update the release
            echo "Updating release with new body (${#NEW_BODY} characters)"
            
            # Use jq to properly escape the JSON
            JSON_PAYLOAD=$(jq -n --arg body "$NEW_BODY" '{"body": $body}')
            
            # Debug output
            echo "JSON payload length: ${#JSON_PAYLOAD}"
            
            # Make the API call
            RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID" \
              -d "$JSON_PAYLOAD")
              
            # Split response into body and status code
            HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
            RESPONSE_BODY=$(echo "$RESPONSE" | jq -r '.' 2>/dev/null || echo "$RESPONSE" | head -n -1)
            
            echo "GitHub API response status: $HTTP_STATUS"
            if [ $HTTP_STATUS -ne 200 ]; then
              echo "Error updating release notes:"
              echo "$RESPONSE_BODY"
              exit 1
            fi
            
            echo "âœ… Successfully updated release notes"
          else
            echo "Error: deployments.md not found"
            exit 1
          fi