name: Deploy Soroban Contracts

on:
  push:
    tags:
      - 'deploy-*-v*'       # Standard build (builds CLI from source), format: deploy-vX.Y.Z-{testnet|mainnet|futurenet}
      - 'fast-*-deploy-v*'  # Fast build (downloads pre-built binary), format: fast-deploy-vX.Y.Z-{testnet|mainnet|futurenet}

permissions:
  contents: write
  id-token: write

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: full
  STELLAR_CLI_VERSION: 23.0.1
  TAG_NAME: ${{ github.ref_name }}
  # Default values that will be set in a setup step
  IS_FAST_DEPLOY: "false"
  RELEASE_NAME: ""
  VERSION: ""

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          # Install specific versions that work well together
          pip install 'stellar-sdk==10.0.0' 'cryptography==41.0.7' requests toml selenium webdriver-manager python-dotenv

      - name: Install system dependencies
        run: |
          # Install required system dependencies
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            wget \
            unzip \
            jq \
            libdbus-1-dev \
            pkg-config \
            libusb-1.0-0-dev \
            libudev-dev \
            libssl-dev \
            build-essential \
            cmake
          
      - name: Install system dependencies for stellar-cli
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            libdbus-1-dev \
            pkg-config \
            libusb-1.0-0-dev \
            libftdi1-dev \
            libudev-dev \
            libssl-dev \
            build-essential \
            cmake \
            curl \
            git \
            protobuf-compiler \
            llvm-dev \
            libclang-dev \
            clang

      - name: Set up environment variables
        id: set_env
        run: |
          # Set IS_FAST_DEPLOY
          if [[ ${{ github.ref }} == refs/tags/fast-* ]]; then
            echo "IS_FAST_DEPLOY=true" >> $GITHUB_ENV
            
            # For fast-{release}-deploy-vX.Y.Z-{network}
            TAG_PREFIX=${GITHUB_REF_NAME%%-deploy-*}
            RELEASE_NAME=${TAG_PREFIX#fast-}
            VERSION_WITH_NETWORK=${GITHUB_REF_NAME#*deploy-}
            VERSION=${VERSION_WITH_NETWORK%-*}
            NETWORK=${GITHUB_REF_NAME##*-}
          else
            # For deploy-{release}-vX.Y.Z-{network}
            echo "IS_FAST_DEPLOY=false" >> $GITHUB_ENV
            TAG_PREFIX=${GITHUB_REF_NAME%%-v*}
            RELEASE_NAME=${TAG_PREFIX#deploy-}
            VERSION_WITH_NETWORK=${GITHUB_REF_NAME#*v}
            VERSION=${VERSION_WITH_NETWORK%-*}
            NETWORK=${GITHUB_REF_NAME##*-}
          fi
          
          echo "RELEASE_NAME=$RELEASE_NAME" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "NETWORK=$NETWORK" >> $GITHUB_ENV
          
          # Debug output
          echo "Release name: $RELEASE_NAME"
          echo "Version: $VERSION"
          echo "Network: $NETWORK"
          echo "Is fast deploy: $IS_FAST_DEPLOY"

      - name: Install Rust toolchain
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          components: rustfmt, clippy
          override: true

      - name: Determine build type
        id: build_type
        run: |
          if [[ ${{ github.ref_name }} == fast-* ]]; then
            echo "BUILD_TYPE=fast" >> $GITHUB_ENV
            echo "::set-output name=type::fast"
          else
            echo "BUILD_TYPE=standard" >> $GITHUB_ENV
            echo "::set-output name=type::standard"
          fi
          echo "Build type: ${{ env.BUILD_TYPE }}"

      - name: Install Stellar CLI (Standard Build)
        if: env.BUILD_TYPE == 'standard'
        env:
          PKG_CONFIG_PATH: /usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:/usr/local/lib/pkgconfig
          RUSTFLAGS: '-C target-cpu=native'
        run: |
          echo "Installing Stellar CLI from source..."
          cargo install --locked --version ${{ env.STELLAR_CLI_VERSION }} stellar-cli --force
          stellar --version

      - name: Install Stellar CLI (Fast Build)
        if: env.BUILD_TYPE == 'fast'
        run: |
          echo "Downloading pre-built Stellar CLI..."
          VERSION=${{ env.STELLAR_CLI_VERSION }}
          
          # Download the pre-built binary
          curl -L -o stellar-cli.tar.gz \
            "https://github.com/stellar/stellar-cli/releases/download/v${VERSION}/stellar-cli-${VERSION}-x86_64-unknown-linux-gnu.tar.gz"
          
          # Extract the binary
          tar -xzf stellar-cli.tar.gz
          
          # Make it executable and move to PATH
          chmod +x stellar
          sudo mv stellar /usr/local/bin/
          
          # Verify installation
          echo "Stellar CLI version:"
          stellar --version
          
          # Clean up
          rm -f stellar-cli.tar.gz

      - name: Extract version and network from tag
        id: extract
        run: |
          TAG_NAME=${{ github.ref_name }}
          if [[ $TAG_NAME =~ ^(fast-)?deploy-v([0-9.]+)-([a-z]+)$ ]]; then
            VERSION=${BASH_REMATCH[2]}
            NETWORK=${BASH_REMATCH[3]}
            echo "VERSION=$VERSION" >> $GITHUB_ENV
            echo "NETWORK=$NETWORK" >> $GITHUB_ENV
            echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
            echo "NETWORK=$NETWORK" >> $GITHUB_OUTPUT
            if [[ ! "$NETWORK" =~ ^(testnet|mainnet|futurenet)$ ]]; then
              echo "Invalid network: $NETWORK. Must be testnet, mainnet, or futurenet"
              exit 1
            fi
            
            # Set BUILD_TYPE based on tag prefix
            if [[ ${BASH_REMATCH[1]} == "fast-" ]]; then
              echo "BUILD_TYPE=fast" >> $GITHUB_ENV
            else
              echo "BUILD_TYPE=standard" >> $GITHUB_ENV
            fi
          else
            echo "Invalid tag format: $TAG_NAME. Expected [fast-]deploy-vX.Y.Z-{testnet|mainnet|futurenet}"
            exit 1
          fi

      - name: Debug version and network
        run: |
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Tag: ${{ github.ref_name }}"
          echo "Version: ${{ env.VERSION }}"
          echo "Network: ${{ env.NETWORK }}"
          echo "Stellar CLI version: $(stellar --version)"

      - name: Create wasm directory
        run: mkdir -p wasm

      - name: Download release assets
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ env.VERSION }}"
          CONTRACTS=(
            "pintheon_ipfs_token"
            "pintheon_node_token"
            "opus_token"
            "hvym_collective"
          )
          
          # Fetch all releases and find the latest one matching the version
          echo "Fetching releases to find the latest for version '$VERSION'..."
          RELEASES_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases")

          # Filter releases for the correct tags (vX.Y.Z or fast-release-vX.Y.Z) and find the most recent
          LATEST_RELEASE_INFO=$(echo "$RELEASES_INFO" | jq -r --arg VERSION "$VERSION" '[
            .[] | select(.tag_name == "v\($VERSION)" or .tag_name == "fast-v\($VERSION)")
          ] | sort_by(.created_at) | .[-1] // null')

          if [ -z "$LATEST_RELEASE_INFO" ] || [ "$LATEST_RELEASE_INFO" == "null" ]; then
            echo "::error::No release found for version '$VERSION'."
            exit 1
          fi

          RELEASE_TAG=$(echo "$LATEST_RELEASE_INFO" | jq -r '.tag_name')
          echo "Found latest release for version '$VERSION' with tag: $RELEASE_TAG"
          echo "$LATEST_RELEASE_INFO" > wasm/release_info.json

          # Download all contract wasm files from the latest release
          for CONTRACT in "${CONTRACTS[@]}"; do
            # Try both optimized and non-optimized filenames
            for SUFFIX in ".optimized.wasm" ".wasm"; do
              WASM_FILE="${CONTRACT}${SUFFIX}"
              ASSET_URL=$(echo "$LATEST_RELEASE_INFO" | jq -r --arg WASM_FILE "$WASM_FILE" '.assets[] | select(.name == $WASM_FILE) | .url')
              if [ -n "$ASSET_URL" ]; then
                OUTPUT_FILE="wasm/$(basename "$WASM_FILE")"
                echo "Downloading $WASM_FILE from release $RELEASE_TAG..."
                curl -s -L -H "Authorization: Bearer $GITHUB_TOKEN" \
                     -H "Accept: application/octet-stream" \
                     "$ASSET_URL" -o "$OUTPUT_FILE"
                break # Move to the next contract
              fi
            done
          done

          # Verify all required files were downloaded
          for CONTRACT in "${CONTRACTS[@]}"; do
            if [ ! -f "wasm/${CONTRACT}.wasm" ] && [ ! -f "wasm/${CONTRACT}.optimized.wasm" ]; then
              echo "::error::Failed to download WASM for contract '${CONTRACT}' from release '$RELEASE_TAG'."
              exit 1
            fi
          done

          echo "All required WASM files downloaded successfully."

      - name: List downloaded WASM files
        run: |
          echo "Listing files in wasm/"
          ls -l wasm/ || echo "No files found in wasm/"
          if [ -z "$(ls -A wasm/)" ]; then
            echo "Error: wasm/ is empty"
            exit 1
          fi

      - name: Verify WASM files
        run: |
          # Verify each WASM file exists and is not empty
          for wasm_file in wasm/*.wasm; do
            echo "Verifying $wasm_file"
            if [ ! -s "$wasm_file" ]; then
              echo "::error::WASM file $wasm_file is missing or empty"
              exit 1
            fi
            
            # Basic WASM verification
            if ! wasm-opt --version > /dev/null 2>&1; then
              echo "Skipping wasm-opt validation (not installed)"
            elif ! wasm-opt "$wasm_file" -o /dev/null; then
              echo "::warning::WASM file $wasm_file failed wasm-opt validation"
            else
              echo "$wasm_file passed basic validation"
            fi
          done

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Configure deployment arguments
        id: deploy_config
        run: |
          # Show the configs for debugging
          echo "Deployment arguments:"
          cat hvym_collective_args.json
          echo -e "\nPost-deployment configuration:"
          cat hvym_collective_post_deploy_args.json

      - name: Set up Stellar deployer identity
        id: setup_identity
        run: |
          # Install required Python packages
          python -m pip install stellar-sdk toml
          
          # Run the setup script
          echo "🔧 Setting up Stellar deployer identity for network: ${{ env.NETWORK }}"
          echo "Working directory: $(pwd)"
          
          python setup_deployer_identity.py \
            --secret-key-env ACCT_SECRET \
            --network ${{ env.NETWORK }} \
            --rpc-url https://soroban-testnet.stellar.org
            
          # Verify the identity is usable
          echo "🔍 Verifying identity is usable..."
          IDENTITY_NAME="${{ env.NETWORK }}_DEPLOYER"
          IDENTITY_NAME=$(echo "$IDENTITY_NAME" | tr '[:lower:]' '[:upper:]')
          
          # Save identity name for subsequent steps
          echo "IDENTITY_NAME=$IDENTITY_NAME" >> $GITHUB_ENV
          
          # Get public key from identity for deployment
          PUBLIC_KEY=$(stellar keys public-key "$IDENTITY_NAME" 2>&1)
          if [ $? -ne 0 ]; then
            echo "::error::Failed to get public key from identity: $PUBLIC_KEY"
            exit 1
          fi
          
          echo "✅ Identity setup complete"
          echo "   Identity: $IDENTITY_NAME"
        env:
          ACCT_SECRET: ${{ secrets.ACCT_SECRET }}
          
      - name: Run deployment script
        env:
          NETWORK: ${{ env.NETWORK }}
          RPC_URL: https://soroban-testnet.stellar.org
          STELLAR_NETWORK: ${{ env.NETWORK }}
          STELLAR_RPC_URL: https://soroban-testnet.stellar.org
        run: |
          # Ensure we're in the repository root
          cd "$GITHUB_WORKSPACE"
          
          echo "Running deployment for ${{ env.NETWORK }} in $(pwd)"
          
          # Verify we're in the correct directory by checking for important files
          if [ ! -f "deploy_contracts.py" ] || [ ! -d ".github/workflows" ]; then
            echo "::error::Not in repository root directory. Current directory: $(pwd)"
            exit 1
          fi
          
          # Get the identity name based on network (already verified in setup step)
          IDENTITY_NAME="${{ env.NETWORK }}_DEPLOYER"
          IDENTITY_NAME=$(echo "$IDENTITY_NAME" | tr '[:lower:]' '[:upper:]')
          
          # Get the deployer's public key (already verified in setup step)
          DEPLOYER_PUBLIC_KEY=$(stellar keys public-key "$IDENTITY_NAME")
          echo "🚀 Starting deployment with identity: $IDENTITY_NAME"
          echo "   Public key: $DEPLOYER_PUBLIC_KEY"
          
          # Ensure the wasm directory exists
          if [ ! -d "wasm" ]; then
            echo "::error::WASM directory not found. Make sure contracts are built."
            exit 1
          fi
          
          # Ensure the config directory exists
          mkdir -p config
          
          # Run the deployment script with the correct identity name
          python deploy_contracts.py \
            --deployer-acct "$IDENTITY_NAME" \
            --network "${{ env.NETWORK }}" \
            --wasm-dir wasm
          
          # Save deployment details as an artifact with release information
          if [ -f deployments.json ]; then
            # Add release info to deployments.json
            jq --arg release "${{ env.RELEASE_NAME }}" --arg version "${{ env.VERSION }}" \
              '. + {release: $release, version: $version}' deployments.json > deployment_details.json
            mv deployment_details.json deployments.json  # Update original file too
            cp deployments.json deployment_details.json  # Create a copy for the artifact
          else
            echo "{\"status\": \"error\", \"message\": \"Deployment failed or deployments.json not created\", \"release\": \"${{ env.RELEASE_NAME }}\", \"version\": \"${{ env.VERSION }}\"}" > deployment_details.json
          fi
          
          # Create a summary of the deployment
          echo "## 🚀 ${{ env.RELEASE_NAME }} Deployment Summary (v${{ env.VERSION }})" >> $GITHUB_STEP_SUMMARY
          echo "### Release Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Release Name**: ${{ env.RELEASE_NAME}}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ env.VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment Type**: ${{ env.IS_FAST_DEPLOY == 'true' && 'Fast' || 'Standard' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Details" >> $GITHUB_STEP_SUMMARY
          if [ -f deployments.md ]; then
            cat deployments.md >> $GITHUB_STEP_SUMMARY
          else
            echo "No deployment details available. Check the logs for errors." >> $GITHUB_STEP_SUMMARY
          fi
          
          # Upload deployment details as an artifact
          echo "DEPLOYMENT_DETAILS=deployment_details.json" >> $GITHUB_ENV
          
      - name: Run post-deployment actions for hvym-collective
        if: success()
        run: |
          # Check if post-deployment is enabled
          if [ -f "hvym_collective_post_deploy_args.json" ]; then
            ENABLED=$(jq -r '.enabled // true' hvym_collective_post_deploy_args.json)
            if [ "$ENABLED" = "true" ]; then
              echo "Running post-deployment actions for hvym-collective..."
              
              # Get deployment arguments
              FUND_AMOUNT=$(jq -r '.fund_amount // 30' hvym_collective_post_deploy_args.json)
              INITIAL_OPUS_ALLOC=$(jq -r '.initial_opus_alloc // 1000' hvym_collective_post_deploy_args.json)
              
              # Run post-deployment script
              python hvym_post_deploy.py \
                --deployer-acct "${{ env.IDENTITY_NAME }}" \
                --network "${{ env.NETWORK }}" \
                --fund-amount "$FUND_AMOUNT" \
                --initial-opus-alloc "$INITIAL_OPUS_ALLOC"
                
              echo "✅ Post-deployment actions completed successfully"
            else
              echo "ℹ️ Post-deployment actions are disabled in hvym_collective_post_deploy_args.json"
            fi
          else
            echo "ℹ️ No post-deployment configuration found, using defaults"
            python hvym_post_deploy.py \
              --deployer-acct "$IDENTITY_NAME" \
              --deployer-pubkey "$PUBLIC_KEY" \
              --network "${{ env.NETWORK }}" \
              --fund-amount 30 \
              --initial-opus-alloc 1000
          fi

      - name: Submit to Stellar Expert
        if: success()
        run: |
          echo "🌐 Submitting to Stellar Expert..."
          
          # Verify deployments.json exists
          if [ ! -f "deployments.json" ]; then
            echo "Error: deployments.json not found"
            exit 0  # Don't fail the workflow
          fi
          
          # Get list of contracts from deployments.json
          CONTRACTS=$(jq -r 'keys[] | select(. != "network" and . != "timestamp" and . != "cli_version" and . != "note")' deployments.json)
          
          for CONTRACT in $CONTRACTS; do
            # Extract contract details
            CONTRACT_DATA=$(jq -r ".[\"$CONTRACT\"]" deployments.json)
            WASM_HASH=$(echo "$CONTRACT_DATA" | jq -r '.wasm_hash // empty')
            CONTRACT_ID=$(echo "$CONTRACT_DATA" | jq -r '.contract_id // empty')
            
            if [ -n "$WASM_HASH" ] && [ -n "$CONTRACT_ID" ]; then
              echo "Submitting $CONTRACT to Stellar Expert..."
              echo "  Contract ID: $CONTRACT_ID"
              echo "  WASM Hash: $WASM_HASH"
              
              # Submit to Stellar Expert
              curl -X POST "https://api.stellar.expert/explorer/public/contract-validation/match" \
                -H "Content-Type: application/json" \
                -d '{
                  "repository": "${{ github.repository }}",
                  "commitHash": "${{ github.sha }}",
                  "jobId": "${{ github.job }}",
                  "runId": "${{ github.run_id }}",
                  "contractHash": "'$WASM_HASH'",
                  "contractId": "'$CONTRACT_ID'",
                  "packageName": "'$CONTRACT'",
                  "network": "'${{ env.NETWORK }}'",
                  "makeTarget": "deploy"
                }' || echo "Warning: Failed to submit $CONTRACT to Stellar Expert"
            else
              echo "Skipping $CONTRACT - missing wasm_hash or contract_id"
            fi
          done
          
      - name: Upload deployments.md as artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployments-md
          path: deployments.md

      - name: Update release notes with deployments
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the full tag name (e.g., deploy-v0.03-testnet)
          FULL_TAG="${{ github.ref_name}}"
          echo "Updating release notes for tag: $FULL_TAG"
          
          # Get the release info using the full tag name
          RELEASE_INFO=$(curl -s -H "Authorization: Bearer $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/$FULL_TAG")
            
          # Check if we got a valid response
          if [ "$(echo "$RELEASE_INFO" | jq -r '.message')" = "Not Found" ]; then
            echo "Error: Release $FULL_TAG not found"
            exit 1
          fi
          
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          CURRENT_BODY=$(echo "$RELEASE_INFO" | jq -r '.body // ""')
          
          echo "Current release ID: $RELEASE_ID"
          echo "Current body length: ${#CURRENT_BODY} characters"
          
          # Read the deployments markdown
          if [ -f "deployments.md" ]; then
            DEPLOYMENTS_MD=$(cat deployments.md)
            echo "Read deployments.md (${#DEPLOYMENTS_MD} characters)"
            
            # Prepare the new body - ensure we don't duplicate the deployment details
            if [[ "$CURRENT_BODY" == *"## Deployment Details"* ]]; then
              echo "Found existing Deployment Details section, replacing it"
              NEW_BODY="${CURRENT_BODY%%## Deployment Details*}## Deployment Details\n\n$DEPLOYMENTS_MD"
            else
              NEW_BODY="${CURRENT_BODY}\n\n## Deployment Details\n\n$DEPLOYMENTS_MD"
            fi
            
            # Update the release
            echo "Updating release with new body (${#NEW_BODY} characters)"
            
            # Use jq to properly escape the JSON
            JSON_PAYLOAD=$(jq -n --arg body "$NEW_BODY" '{"body": $body}')
            
            # Debug output
            echo "JSON payload length: ${#JSON_PAYLOAD}"
            
            # Make the API call
            RESPONSE=$(curl -s -w "\n%{http_code}" -X PATCH \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/releases/$RELEASE_ID" \
              -d "$JSON_PAYLOAD")
              
            # Split response into body and status code
            HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
            RESPONSE_BODY=$(echo "$RESPONSE" | jq -r '.' 2>/dev/null || echo "$RESPONSE" | head -n -1)
            
            echo "GitHub API response status: $HTTP_STATUS"
            if [ $HTTP_STATUS -ne 200 ]; then
              echo "Error updating release notes:"
              echo "$RESPONSE_BODY"
              exit 1
            fi
            
            echo "✅ Successfully updated release notes"
          else
            echo "Error: deployments.md not found"
            exit 1
          fi