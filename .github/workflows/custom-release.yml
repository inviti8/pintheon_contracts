name: Build and Release Soroban Contracts

on:
  push: 
    tags:
      - 'release-*-v*'        # Standard build (builds CLI from source)
      - 'fast-release-*-v*'   # Fast build (downloads pre-built binary)

permissions:
  id-token: write  # Required for OIDC token generation
  contents: write  # Required for creating releases
  attestations: write  # Required for build attestations
  # Additional permissions for the release job
  actions: read  # Required for workflow run information
  checks: read   # Required for commit status checks

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: full
  STELLAR_CLI_VERSION: 23.4.0
  TAG_NAME: ${{ github.ref_name }}
  # Default values that will be set in a setup step
  IS_FAST_RELEASE: "false"
  RELEASE_NAME: ""
  VERSION: ""
  WASM_PATH: wasm
  PACKAGE_NAME: ''  # Will be set per contract
  RELATIVE_PATH: '' # Will be set per contract
  MAKE_TARGET: ''   # Will be set per contract

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up environment variables
        id: set_env
        run: |
          # Set IS_FAST_RELEASE
          if [[ ${{ github.ref }} == refs/tags/fast-release-* ]]; then
            echo "IS_FAST_RELEASE=true" >> $GITHUB_ENV
            
            # For fast-release-{name}-vX.Y.Z
            TAG_PREFIX=${GITHUB_REF_NAME#fast-release-}
            RELEASE_NAME=${TAG_PREFIX%%-v*}
            VERSION=${GITHUB_REF_NAME##*-v}
          else
            # For release-{name}-vX.Y.Z
            echo "IS_FAST_RELEASE=false" >> $GITHUB_ENV
            TAG_PREFIX=${GITHUB_REF_NAME#release-}
            RELEASE_NAME=${TAG_PREFIX%%-v*}
            VERSION=${GITHUB_REF_NAME##*-v}
          fi
          
          echo "RELEASE_NAME=$RELEASE_NAME" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          
          # Debug output
          echo "Release name: $RELEASE_NAME"
          echo "Version: $VERSION"
          echo "Is fast release: $IS_FAST_RELEASE"
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
          cache: 'pip'

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          targets: wasm32-unknown-unknown,wasm32v1-none
          override: true
          components: rustfmt, clippy
          
      - name: Install wasm32v1 target
        run: rustup target add wasm32v1-none
        
      - name: Show installed targets
        run: rustup target list --installed
      
      - name: Install wasm-opt
        run: |
          wget https://github.com/WebAssembly/binaryen/releases/download/version_116/binaryen-version_116-x86_64-linux.tar.gz
          tar xzf binaryen-version_116-x86_64-linux.tar.gz
          sudo cp binaryen-version_116/bin/wasm-opt /usr/local/bin/
      
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            libssl-dev \
            libudev-dev \
            pkg-config \
            libusb-1.0-0-dev

      - name: Install Stellar CLI dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libdbus-1-dev pkg-config
          
      - name: Determine build type
        id: build_type
        run: |
          if [[ "${{ env.IS_FAST_RELEASE }}" == "true" ]]; then
            echo "BUILD_TYPE=fast" >> $GITHUB_ENV
            echo "type=fast" >> $GITHUB_OUTPUT
          else
            echo "BUILD_TYPE=standard" >> $GITHUB_ENV
            echo "type=standard" >> $GITHUB_OUTPUT
          fi
          echo "Build type: ${{ env.BUILD_TYPE }}"

      - name: Install Stellar CLI (Standard Build)
        if: env.BUILD_TYPE == 'standard'
        run: |
          echo "Installing Stellar CLI from source..."
          cargo install --locked --version ${{ env.STELLAR_CLI_VERSION }} stellar-cli
          stellar --version

      - name: Install Stellar CLI (Fast Build)
        if: env.BUILD_TYPE == 'fast'
        run: |
          echo "Downloading pre-built Stellar CLI..."
          VERSION=${{ env.STELLAR_CLI_VERSION }}
          
          # Download the pre-built binary
          curl -L -o stellar-cli.tar.gz \
            "https://github.com/stellar/stellar-cli/releases/download/v${VERSION}/stellar-cli-${VERSION}-x86_64-unknown-linux-gnu.tar.gz"
          
          # Extract the binary
          tar -xzf stellar-cli.tar.gz
          
          # Make it executable and move to PATH
          chmod +x stellar
          sudo mv stellar /usr/local/bin/
          
          # Verify installation
          echo "Stellar CLI version:"
          stellar --version
          
          # Clean up
          rm -f stellar-cli.tar.gz
          
      - name: Set up Rust toolchain
        run: |
          rustup toolchain install stable
          rustup default stable
          rustup target add wasm32v1-none
          rustup target list --installed
          
      - name: Create wasm directory
        run: |
          mkdir -p wasm
          chmod -R 777 wasm
          
      - name: Set up build environment
        run: |
          # Log the current directory structure
          echo "=== Current directory structure ==="
          find . -maxdepth 3 -type d | sort
          
          # Create and set permissions for the wasm directory
          mkdir -p wasm
          chmod -R 777 wasm
          
          # Create wasm directories in each contract directory
          for dir in pintheon-node-deployer/pintheon-node-token \
                     pintheon-ipfs-deployer/pintheon-ipfs-token \
                     opus_token \
                     hvym-collective \
                     hvym-roster \
                     hvym-pin-service \
                     hvym-pin-service-factory; do
            mkdir -p "$dir/wasm"
            chmod -R 777 "$dir/wasm"
            
            # Log the directory structure for each contract
            echo -e "\n=== Contents of $dir ==="
            ls -la "$dir" || echo "Could not list $dir"
            
            echo -e "\n=== Contents of $dir/target ==="
            ls -la "$dir/target" 2>/dev/null || echo "No target directory in $dir"
            
            echo -e "\n=== Contents of $dir/wasm ==="
            ls -la "$dir/wasm" 2>/dev/null || echo "No wasm directory in $dir"
          done
          
          # Install Python dependencies
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          
          # Log the Python environment
          echo -e "\n=== Python environment ==="
          python --version
          pip list
          
      - name: Build contracts in sequence
        run: |
          # Define contract build configurations
          declare -A CONTRACTS=(
            ["pintheon-node-deployer/pintheon-node-token"]="pintheon_node_token"
            ["pintheon-ipfs-deployer/pintheon-ipfs-token"]="pintheon_ipfs_token"
            ["opus_token"]="opus_token"
          )

          # Build each contract one by one with proper error handling
          for contract_path in "${!CONTRACTS[@]}"; do
            contract_name="${CONTRACTS[$contract_path]}"
            wasm_file="wasm/${contract_name}.optimized.wasm"
            
            echo "\nðŸš€ Building $contract_path..."
            
            # Set contract-specific environment variables
            echo "PACKAGE_NAME=${contract_name}" >> $GITHUB_ENV
            echo "RELATIVE_PATH=${contract_path}" >> $GITHUB_ENV
            echo "WASM_PATH=${wasm_file}" >> $GITHUB_ENV
            
            # Build the contract with source repo info
            if ! python cloud_build.py --contract "$contract_path" --source-repo "github:${{ github.repository }}"; then
              echo "::error::Failed to build $contract_path"
              exit 1
            fi
            
            # Verify the optimized WASM file was created
            if [ ! -f "$wasm_file" ]; then
              echo "::error::Optimized WASM not found after building $contract_path"
              echo "Expected: $(pwd)/$wasm_file"
              echo "Current directory contents:"
              ls -la wasm/ || echo "No wasm directory found"
              exit 1
            fi
            
            echo "âœ… Successfully built and verified: $wasm_file"
            echo "File size: $(du -h "$wasm_file" | cut -f1)"
            
            # Generate contract hash using the metadata approach
            echo "\nðŸ”‘ Generating contract hash..."
            
            # First try with the with_meta version if it exists
            wasm_with_meta="${wasm_file%.optimized.wasm}.with_meta.wasm"
            if [ -f "$wasm_with_meta" ]; then
                echo "Using WASM with metadata: $(basename "$wasm_with_meta")"
                wasm_file="$wasm_with_meta"
            fi
            
            # Get the hash using the build info command
            WASM_HASH=$(stellar contract info build --wasm "$wasm_file" 2>&1 | grep -o 'Wasm Hash: .*' | cut -d' ' -f3)
            
            if [ -z "$WASM_HASH" ]; then
                echo "::error::Failed to generate contract hash"
                echo "Tried to get hash from: $wasm_file"
                echo "Command output was:"
                stellar contract info build --wasm "$wasm_file" || true
                exit 1
            fi
            
            echo "WASM_HASH=$WASM_HASH" >> $GITHUB_ENV
            echo "Hash: $WASM_HASH"
            
            # Attest build
            echo "\nðŸ“ Attesting build..."
            echo "Attesting: $wasm_file"
            echo "Subject: $wasm_file"
            
            # Create build provenance
            echo "::notice::Generating build provenance for $wasm_file"
            
            echo "\nâœ… Successfully processed $contract_name"
          done
          
          # Now build hvym-collective with the same attestation process
          contract_path="hvym-collective"
          contract_name="hvym_collective"
          wasm_file="wasm/${contract_name}.optimized.wasm"
          
          echo "\nðŸš€ Building $contract_path..."
          
          # Set contract-specific environment variables
          echo "PACKAGE_NAME=${contract_name}" >> $GITHUB_ENV
          echo "RELATIVE_PATH=${contract_path}" >> $GITHUB_ENV
          echo "WASM_PATH=${wasm_file}" >> $GITHUB_ENV
          
          # Build the contract with source repo info
          if ! python cloud_build.py --contract "$contract_path" --source-repo "github:${{ github.repository }}"; then
            echo "::error::Failed to build $contract_path"
            exit 1
          fi
          
          # Verify the optimized WASM file was created
          if [ ! -f "$wasm_file" ]; then
            echo "::error::Optimized WASM not found after building $contract_path"
            echo "Expected: $(pwd)/$wasm_file"
            exit 1
          fi
          
          echo "âœ… Successfully built and verified: $wasm_file"
          echo "File size: $(du -h "$wasm_file" | cut -f1)"
          
          # Generate contract hash using the metadata approach for hvym-collective
          echo "\nðŸ”‘ Generating contract hash for hvym-collective..."
          
          # First try with the with_meta version if it exists
          wasm_with_meta="${wasm_file%.optimized.wasm}.with_meta.wasm"
          if [ -f "$wasm_with_meta" ]; then
              echo "Using WASM with metadata: $(basename "$wasm_with_meta")"
              wasm_file="$wasm_with_meta"
          fi
          
          # Get the hash using the build info command
          WASM_HASH=$(stellar contract info build --wasm "$wasm_file" 2>&1 | grep -o 'Wasm Hash: .*' | cut -d' ' -f3)
          
          if [ -z "$WASM_HASH" ]; then
              echo "::error::Failed to generate contract hash for hvym-collective"
              echo "Tried to get hash from: $wasm_file"
              echo "Command output was:"
              stellar contract info build --wasm "$wasm_file" || true
              exit 1
          fi
          
          echo "WASM_HASH=$WASM_HASH" >> $GITHUB_ENV
          echo "Hash: $WASM_HASH"
          
          # Attest build
          echo "\nðŸ“ Attesting build..."

          echo "\nâœ… Successfully processed $contract_name"

          # Now build hvym-roster with the same attestation process
          contract_path="hvym-roster"
          contract_name="hvym_roster"
          wasm_file="wasm/${contract_name}.optimized.wasm"

          echo "\nðŸš€ Building $contract_path..."

          # Set contract-specific environment variables
          echo "PACKAGE_NAME=${contract_name}" >> $GITHUB_ENV
          echo "RELATIVE_PATH=${contract_path}" >> $GITHUB_ENV
          echo "WASM_PATH=${wasm_file}" >> $GITHUB_ENV

          # Build the contract with source repo info
          if ! python cloud_build.py --contract "$contract_path" --source-repo "github:${{ github.repository }}"; then
            echo "::error::Failed to build $contract_path"
            exit 1
          fi

          # Verify the optimized WASM file was created
          if [ ! -f "$wasm_file" ]; then
            echo "::error::Optimized WASM not found after building $contract_path"
            echo "Expected: $(pwd)/$wasm_file"
            exit 1
          fi

          echo "âœ… Successfully built and verified: $wasm_file"
          echo "File size: $(du -h "$wasm_file" | cut -f1)"

          # Generate contract hash using the metadata approach for hvym-roster
          echo "\nðŸ”‘ Generating contract hash for hvym-roster..."

          # First try with the with_meta version if it exists
          wasm_with_meta="${wasm_file%.optimized.wasm}.with_meta.wasm"
          if [ -f "$wasm_with_meta" ]; then
              echo "Using WASM with metadata: $(basename "$wasm_with_meta")"
              wasm_file="$wasm_with_meta"
          fi

          # Get the hash using the build info command
          WASM_HASH=$(stellar contract info build --wasm "$wasm_file" 2>&1 | grep -o 'Wasm Hash: .*' | cut -d' ' -f3)

          if [ -z "$WASM_HASH" ]; then
              echo "::error::Failed to generate contract hash for hvym-roster"
              echo "Tried to get hash from: $wasm_file"
              echo "Command output was:"
              stellar contract info build --wasm "$wasm_file" || true
              exit 1
          fi

          echo "WASM_HASH=$WASM_HASH" >> $GITHUB_ENV
          echo "Hash: $WASM_HASH"

          # Attest build
          echo "\nðŸ“ Attesting build..."

          echo "\nâœ… Successfully processed $contract_name"

          # Now build hvym-pin-service with the same attestation process
          contract_path="hvym-pin-service"
          contract_name="hvym_pin_service"
          wasm_file="wasm/${contract_name}.optimized.wasm"

          echo "\nðŸš€ Building $contract_path..."

          # Set contract-specific environment variables
          echo "PACKAGE_NAME=${contract_name}" >> $GITHUB_ENV
          echo "RELATIVE_PATH=${contract_path}" >> $GITHUB_ENV
          echo "WASM_PATH=${wasm_file}" >> $GITHUB_ENV

          # Build the contract with source repo info
          if ! python cloud_build.py --contract "$contract_path" --source-repo "github:${{ github.repository }}"; then
            echo "::error::Failed to build $contract_path"
            exit 1
          fi

          # Verify the optimized WASM file was created
          if [ ! -f "$wasm_file" ]; then
            echo "::error::Optimized WASM not found after building $contract_path"
            echo "Expected: $(pwd)/$wasm_file"
            exit 1
          fi

          echo "âœ… Successfully built and verified: $wasm_file"
          echo "File size: $(du -h "$wasm_file" | cut -f1)"

          # Generate contract hash using the metadata approach for hvym-pin-service
          echo "\nðŸ”‘ Generating contract hash for hvym-pin-service..."

          # First try with the with_meta version if it exists
          wasm_with_meta="${wasm_file%.optimized.wasm}.with_meta.wasm"
          if [ -f "$wasm_with_meta" ]; then
              echo "Using WASM with metadata: $(basename "$wasm_with_meta")"
              wasm_file="$wasm_with_meta"
          fi

          # Get the hash using the build info command
          WASM_HASH=$(stellar contract info build --wasm "$wasm_file" 2>&1 | grep -o 'Wasm Hash: .*' | cut -d' ' -f3)

          if [ -z "$WASM_HASH" ]; then
              echo "::error::Failed to generate contract hash for hvym-pin-service"
              echo "Tried to get hash from: $wasm_file"
              echo "Command output was:"
              stellar contract info build --wasm "$wasm_file" || true
              exit 1
          fi

          echo "WASM_HASH=$WASM_HASH" >> $GITHUB_ENV
          echo "Hash: $WASM_HASH"

          # Attest build
          echo "\nðŸ“ Attesting build..."

          echo "\nâœ… Successfully processed $contract_name"

          # Now build hvym-pin-service-factory with the same attestation process
          contract_path="hvym-pin-service-factory"
          contract_name="hvym_pin_service_factory"
          wasm_file="wasm/${contract_name}.optimized.wasm"

          echo "\nðŸš€ Building $contract_path..."

          # Set contract-specific environment variables
          echo "PACKAGE_NAME=${contract_name}" >> $GITHUB_ENV
          echo "RELATIVE_PATH=${contract_path}" >> $GITHUB_ENV
          echo "WASM_PATH=${wasm_file}" >> $GITHUB_ENV

          # Build the contract with source repo info
          if ! python cloud_build.py --contract "$contract_path" --source-repo "github:${{ github.repository }}"; then
            echo "::error::Failed to build $contract_path"
            exit 1
          fi

          # Verify the optimized WASM file was created
          if [ ! -f "$wasm_file" ]; then
            echo "::error::Optimized WASM not found after building $contract_path"
            echo "Expected: $(pwd)/$wasm_file"
            exit 1
          fi

          echo "âœ… Successfully built and verified: $wasm_file"
          echo "File size: $(du -h "$wasm_file" | cut -f1)"

          # Generate contract hash using the metadata approach for hvym-pin-service-factory
          echo "\nðŸ”‘ Generating contract hash for hvym-pin-service-factory..."

          # First try with the with_meta version if it exists
          wasm_with_meta="${wasm_file%.optimized.wasm}.with_meta.wasm"
          if [ -f "$wasm_with_meta" ]; then
              echo "Using WASM with metadata: $(basename "$wasm_with_meta")"
              wasm_file="$wasm_with_meta"
          fi

          # Get the hash using the build info command
          WASM_HASH=$(stellar contract info build --wasm "$wasm_file" 2>&1 | grep -o 'Wasm Hash: .*' | cut -d' ' -f3)

          if [ -z "$WASM_HASH" ]; then
              echo "::error::Failed to generate contract hash for hvym-pin-service-factory"
              echo "Tried to get hash from: $wasm_file"
              echo "Command output was:"
              stellar contract info build --wasm "$wasm_file" || true
              exit 1
          fi

          echo "WASM_HASH=$WASM_HASH" >> $GITHUB_ENV
          echo "Hash: $WASM_HASH"

          # Attest build
          echo "\nðŸ“ Attesting build..."

          echo "\nâœ… Successfully processed $contract_name"

          # Final verification of all WASM files
          echo "\nðŸ” Verifying all WASM files..."
          for contract in pintheon_node_token pintheon_ipfs_token opus_token hvym_collective hvym_roster hvym_pin_service hvym_pin_service_factory; do
            wasm_file="wasm/${contract}.optimized.wasm"
            if [ ! -f "$wasm_file" ]; then
              echo "::error::Missing final WASM file: $wasm_file"
              exit 1
            fi
            
            # Generate and display hash for each contract
            hash=$(stellar contract hash --wasm "$wasm_file" 2>/dev/null || echo "error")
            if [ "$hash" != "error" ]; then
              echo "âœ… ${contract}: ${hash:0:8}...${hash: -8} ($(du -h "$wasm_file" | cut -f1))"
            else
              echo "âœ… ${contract}: Error generating hash ($(du -h "$wasm_file" | cut -f1))"
            fi
          done
          
      - name: Verify WASM files
        run: |
          echo "Built WASM files in wasm/ directory:"
          ls -la wasm/
          # Verify each contract was built
          for contract in pintheon_node_token pintheon_ipfs_token opus_token hvym_collective hvym_roster hvym_pin_service hvym_pin_service_factory; do
            wasm_file="wasm/${contract}.optimized.wasm"
            if [ ! -f "$wasm_file" ]; then
              echo "::error::Failed to find built WASM for ${contract}"
              exit 1
            else
              echo "âœ… Found WASM for ${contract}: $(ls -la "$wasm_file")"
            fi
          done

      - name: Prepare release assets
        run: |
          # Create release directory
          mkdir -p release-wasm
          
          # Copy all optimized WASM and metadata files from wasm/ to release directory
          for contract in pintheon_node_token pintheon_ipfs_token opus_token hvym_collective hvym_roster hvym_pin_service hvym_pin_service_factory; do
            wasm_file="wasm/${contract}.optimized.wasm"
            meta_file="${wasm_file}.meta.json"
            
            # Copy WASM file
            if [ -f "$wasm_file" ]; then
              cp "$wasm_file" "release-wasm/$(basename "$wasm_file")"
              echo "âœ… Copied $wasm_file to release directory"
            else
              echo "::warning::WASM file not found: $wasm_file"
            fi
            
            # Copy metadata file if it exists
            if [ -f "$meta_file" ]; then
              cp "$meta_file" "release-wasm/$(basename "$meta_file")"
              echo "âœ… Copied $meta_file to release directory"
            else
              echo "::warning::Metadata file not found: $meta_file"
            fi
          done
          
          # List all files in release directory
          echo "Release assets prepared:"
          ls -la release-wasm/
          
          # Generate checksums
          (cd release-wasm && sha256sum *.wasm > checksums.sha256)
          cat release-wasm/checksums.sha256
          
      - name: Generate contract metadata
        run: |
          # Generate metadata for each contract
          for contract in pintheon_node_token pintheon_ipfs_token opus_token hvym_collective hvym_roster hvym_pin_service hvym_pin_service_factory; do
            wasm_file="wasm/${contract}.optimized.wasm"
            if [ -f "$wasm_file" ]; then
              echo "Generating metadata for $wasm_file"
              stellar contract env-meta --wasm "$wasm_file" > "${wasm_file}.meta.json" 2>&1 || echo "Warning: Failed to generate metadata for $wasm_file"
            fi
          done
          
          # List all generated metadata files
          find . -name "*.meta.json" -exec ls -la {} \;

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            wasm/*.wasm
            wasm/*.meta.json
            release-wasm/
          retention-days: 7
          
      - name: Generate release body
        id: release_body
        run: |
          # Get the release name and format it nicely
          RELEASE_NAME="${{ env.RELEASE_NAME }}"
          VERSION="${{ env.VERSION }}"
          
          # Generate markdown with release info and verification
          RELEASE_BODY="# $RELEASE_NAME Release - $VERSION\n\n"
          
          # Add build information section
          RELEASE_BODY+="## ðŸ“¦ Build Information\n"
          RELEASE_BODY+="- **Release Type**: ${{ contains(github.ref, 'fast-') && 'ðŸš€ Fast Build' || 'ðŸ—ï¸ Standard Build' }}\n"
          RELEASE_BODY+="- **Version**: $VERSION\n"
          RELEASE_BODY+="- **Commit**: [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})\n"
          RELEASE_BODY+="- **Build Date**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')\n"
          RELEASE_BODY+="- **Build Run**: [#$GITHUB_RUN_ID](https://github.com/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID)\n\n"
          
          # Add verification section
          RELEASE_BODY+="## ðŸ” Verification\n"
          RELEASE_BODY+="This release has been verified and attested by Stellar Expert.\n\n"
          RELEASE_BODY+="### ðŸ“œ Verified Contracts\n"
          
          # Add each contract's verification info
          for wasm in wasm/*.optimized.wasm; do
            if [ -f "$wasm" ]; then
              contract_name=$(basename "$wasm" ".optimized.wasm")
              hash=$(stellar contract hash --wasm "$wasm" 2>/dev/null || echo "error")
              
              if [ "$hash" != "error" ]; then
                RELEASE_BODY+="- **${contract_name}**: "
                RELEASE_BODY+="[View on Stellar Expert](https://stellar.expert/explorer/testnet/contract/$hash)\n"
                RELEASE_BODY+="  - Hash: ${hash:0:8}...${hash: -8}\n"
              fi
            fi
          done
          
          # Set the output for the release step
          delimiter="EOF_$(date +%s)"
          echo "RELEASE_BODY<<$delimiter" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "$delimiter" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release-wasm/*.wasm
            release-wasm/*.meta.json
            release-wasm/checksums.sha256
          tag_name: ${{ env.VERSION }}
          name: Release ${{ env.VERSION }}
          body: ${{ steps.release_body.outputs.RELEASE_BODY }}
